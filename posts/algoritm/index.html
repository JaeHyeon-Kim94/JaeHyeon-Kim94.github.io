<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Algoritm" /><meta property="og:locale" content="ko" /><meta name="description" content="Ch01. 기본 알고리즘" /><meta property="og:description" content="Ch01. 기본 알고리즘" /><link rel="canonical" href="https://jaehyeon-kim94.github.io/posts/algoritm/" /><meta property="og:url" content="https://jaehyeon-kim94.github.io/posts/algoritm/" /><meta property="og:site_name" content="JaeHyeon" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-05-16T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Algoritm" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-11-02T22:35:40+09:00","datePublished":"2022-05-16T00:00:00+09:00","description":"Ch01. 기본 알고리즘","headline":"Algoritm","mainEntityOfPage":{"@type":"WebPage","@id":"https://jaehyeon-kim94.github.io/posts/algoritm/"},"url":"https://jaehyeon-kim94.github.io/posts/algoritm/"}</script><title>Algoritm | JaeHyeon</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="JaeHyeon"><meta name="application-name" content="JaeHyeon"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">JaeHyeon</a></div><div class="site-subtitle font-italic">학습 정리용 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/JaeHyeon-Kim94" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Algoritm</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Algoritm</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1652626800" data-df="ll" data-toggle="tooltip" data-placement="bottom"> May 16, 2022 </em> </span> <span> Updated <em class="" data-ts="1667396140" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Nov 2, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/username">JaeHyeon-Kim</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="11228 words"> <em>62 min</em> read</span></div></div></div><div class="post-content"><h2 id="ch01-기본-알고리즘"><span class="mr-2">Ch01. 기본 알고리즘</span><a href="#ch01-기본-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>구조적 프로그래밍(Structured Programming)<ul><li>하나의 입구와 하나의 출구를 가진 구성 요소만을 계층적으로 배치하여 프로그램을 구성하는 방식<li>제어 흐름 : 순차, 선택, 반복</ul><li>드모르간 법칙<ul><li>각 조건을 부정하고 논리곱(AND)을 논리합(OR)으로, 논리합을 논리곱으로 바꾸고 다시 전체를 부정하면 원래의 조건과 같다는 법칙</ul></ul><p><br /> <br /></p><h2 id="ch02-기본-자료구조"><span class="mr-2">Ch02. 기본 자료구조</span><a href="#ch02-기본-자료구조" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>다차원 배열 clone : 최상위의 1레벨만 수행하며, 그 아래 레벨의 배열은 참조를 공유한다.</ul><p><br /> <br /></p><h2 id="ch03-검색"><span class="mr-2">Ch03. 검색</span><a href="#ch03-검색" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="03-1-검색-알고리즘"><span class="mr-2">03-1 검색 알고리즘</span><a href="#03-1-검색-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong><em>TODO</em></strong></p><blockquote><ol><li>선형 검색 : 무작위로 늘어놓은 데이터 집합에서 검색 수행.<li>이진 검색 : 일정한 규칙으로 늘어놓은 데이터 집합에서 아주 빠른 검색 수행.<li>해시법 : 추가, 삭제가 자주 일어나는 데이터 집합에서 아주 빠른 검색 수행. <br />   <span style="color:#2D3748; background-color:#fff5b1">- 체인법 : 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법</span> <br />   <span style="color:#2D3748; background-color:#fff5b1">- 오픈 주소법 : 데이터를 위한 해시 값이 충돌할 때 재해시 하는 방법</span></ol></blockquote><p>데이터의 집합에 대한 검색, 추가, 삭제 등의 작업에 소요되는 비용을 종합적으로 판단하여 알고리즘 선택해야 한다.</p><p><br /><br /></p><h3 id="03-2-선형-검색linear-search"><span class="mr-2">03-2 선형 검색(linear search)</span><a href="#03-2-선형-검색linear-search" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>직선으로 늘어선 요소들에 대해 검색을 할 때, 원하는 요소를 찾을 때까지 맨 앞부터 순차적으로 검색.<ul><li>선형 검색(linear search), 순차 검색 알고리즘(sequential search)</ul><li>검색 종료 조건<ol><li>검색 값을 발견하지 못하고 배열의 끝을 지나간 경우<li>검색할 값과 같은 요소를 발견한 경우</ol><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>    <span class="c1">//선형 검색 while</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">seqSearchW</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">key</span><span class="o">){</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span>      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]==</span><span class="n">key</span><span class="o">)</span>   <span class="k">return</span> <span class="n">i</span><span class="o">;</span>

            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">seqSearchF</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">key</span><span class="o">){</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>

            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></table></code></div></div><p><br /></p><ul><li><p><strong>보초법</strong></p><ul><li><p>선형 검색은 검색시 상기의 종료 조건 1, 2를 모두 판단하는데, 이 과정에서 소요되는 비용을 반으로 줄이는 방법.</p><li>검색하고자 하는 요소값을 배열의 맨 마지막 요소로 넣는다. 이렇게 하면 종료조건 1을 무시하고 2만 판단하면 됨.<li><p>즉, 보초법은 반복이 종료되는 조건에 해당하는 값을 이용해 둘의 종료 조건을 하나로 줄이는 것에 의미가 있음.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">int</span> <span class="nf">seqSearchSen</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">key</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>

    <span class="n">a</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
        <span class="n">i</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">i</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong><em>TODO</em></strong></p></ul></ul><li>판단 횟수 : 배열의 요솟수가 n개라면 <span style="color:#2D3748; background-color:#fff5b1">평균 n/2회</span>. 원하는 값이 배열에 존재하지 않는 경우 조건 1은 n+1, 2는 n회</ul><h3 id="03-3-이진-검색binary-search"><span class="mr-2">03-3 이진 검색(binary search)</span><a href="#03-3-이진-검색binary-search" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>데이터가 키 값으로 이미 정렬되어 있어야 한다. 오름차순 혹은 내림차순으로 정렬된 배열에서 검색하는 알고리즘.</p><li><p>linear search보다 검색이 좀 더 빠르다.</p><li><p>검색방식</p><ul><li><p>정렬된 배열의 정중앙 요소부터 검색을 시작한다. 해당 요소와 검색할 요소의 크기를 비교함으로써 범위가 반으로 줄어든다.</p><ul><li>오름차순으로 정렬된 배열을 기준으로, 검색 범위의 맨 앞 인덱스를 L, 맨 끝 인덱스를 R, 중앙을 C라고 할 때,<li>n개의 요소를 가진 배열의 검색 시작시 L 은 0, R은 n-1, C는 (n-1)/2로 초기화 되며<li>배열[C] &gt; key일때 검색 대상은 왼쪽 영역에 있는 것이 분명하므로, 배열[L] ~ 배열[C-1] 로 검색범위를 좁히며 R은 C-1로 업데이트 됨.<li>반대로 배열[C] &lt; key일때 검색범위는 배열[C+1] ~ 배열[R], L은 C+1</ul><li>해당 과정을 반복한다.<li>검색 대상이 2개로 좁혀졌을 때에는 둘 중 앞의 값을 선택한다.</ul><li>검색 종료 조건<ul><li>조건 1 : 배열[C]와 key가 일치하는 경우<li>조건 2 : 검색 범위가 더이상 없는 경우<ul><li>ex) L이 R보다 커지는 경우 혹은 R이 L보다 작아지는 경우</ul></ul><li>비교횟수<ul><li>평균값 : log n<li>검색 실패시 log(n+1)회, 성공시 log n-1 회.</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">key</span><span class="o">){</span>
  <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>

  <span class="k">do</span><span class="o">{</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="k">return</span> <span class="n">c</span>
    <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">)</span> <span class="n">l</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">r</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span><span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">);</span>
    
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><li><strong>복잡도</strong><ul><li><p>알고리즘의 성능을 객관적으로 평가하는 기준으로서 <br /><strong>시간 복잡도</strong>(실행에 필요한 시간)와 <br /><strong>공간 복잡도</strong>(기억 영역과 파일 공간이 얼마나 필요한가) 두 가지 요소 지님.</p><li><p>시간 복잡도</p><ul><li><p>단순히 값을 반환, 대입하는 일회성 실행의 경우에는 <code class="language-plaintext highlighter-rouge">O(1)</code>로 표기</p><li><p>실행 횟수가 비례하여 증가하는 경우에는 복잡도를 <code class="language-plaintext highlighter-rouge">O(n)</code>으로 표기.</p><li><p>O(f(n))과 O(g(n))의 복잡도 계산 방법</p><ul><li><code class="language-plaintext highlighter-rouge">O(f(n)) + O(g(n)) = O(max(f(n), g(n)))</code><blockquote><p>max(a, b)는 a와 b가운데 큰 쪽을 나타내는 메서드.</p></blockquote><li>for문을 이용한 선형 검색 코드를 기준으로 시간 복잡도를 나타내보면,<ul><li>int i를 선언하고 할당하는 부분은 한 번만 수행되므로 <strong>O(1)</strong><li>대소 비교 부분의 평균 실행 횟수는 <strong>n/2</strong><li>증가 연산자도 <strong>n/2</strong><li>a[i] == key 부분도 <strong>n/2</strong><li>i 리턴은 한 번만 수행되므로 <strong>O(1)</strong><li><p>검색 실패시 -1 리턴은 한 번만 수행되므로 <strong>O(1)</strong></p><li><p>컴퓨터에게 n/2나 n이나 차이 없으므로</p><li>O(1) + O(n) + O(n) + O(1) + O(n) + O(1) <br /> = O(max(1, n, n, 1, n, 1)) <br /> = O(n) <br /></ul></ul></ul></ul><li><p><strong>Arrays.binarySearch에 의한 이진 검색</strong></p><ul><li><p>java.util.Array 클래스의 binarySearch 메서드는 오름차순으로 정렬된 배열 a를 가정하고, 키 값이 key인 요소를 이진검색 함. 자료형에 따라 오버로딩 되어있음.</p><ul><li>타입 : byte[], char[], double[], float[], int[], long[], short[], Object[], 제네릭<li>검색 성공시 key와 일치하는 요소의 인덱스를 리턴하는데, 여러개일 경우 무작위 인덱스 반환.<li>검색 실패시 삽입 포인트(key보다 큰 요소 중 첫 번째 요소의 인덱스)를 x라고 했을 때, -x-1 반환.</ul><li><p>객체의 배열에서 검색</p><ul><li><code class="language-plaintext highlighter-rouge">static int binarySearch(Object[] a, Object key)</code><ul><li>자연 정렬이라는 방법으로 요소의 대소 관계를 판단. 정수 배열, 문자열 배열에서 검색시 적절.<ul><li>자연 정렬과 문자열 정렬<br /> 문자열 정렬은 동일한 위치에 있는 문자의 대소 비교를 통해 정렬한다.</ul><div class="table-wrapper"><table><thead><tr><th>문자열 정렬<th>자연 정렬<tbody><tr><td>텍스트1.txt<td>텍스트1.txt<tr><td>텍스트10.txt<td>텍스트2.txt<tr><td>텍스트100txt<td>텍스트10.txt<tr><td>텍스트2.txt<td>텍스트21.txt<tr><td>텍스트21.txt<td>텍스트100.txt</table></div></ul><li><code class="language-plaintext highlighter-rouge">static &lt;T&gt; int binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)</code><ul><li>자연 순서가 아닌 순서로 줄지어 있는 배열에서 검색하거나 자연 순서를 논리적으로 갖지 않는 클래스 배열에서 검색할 때 적절.<li>Comparator : 클래스 T(또는 클래스 T의 슈퍼 클래스)로 생성한 두 객체의 대소 관계를 판단하기 위한 인터페이스. compare 메서드를 구현해 사용한다.<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="n">foo</span> <span class="kd">implements</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
  <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="no">T</span> <span class="n">o1</span><span class="o">,</span> <span class="no">T</span> <span class="n">o2</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">o1</span> <span class="o">&gt;</span> <span class="n">o2</span><span class="o">)</span> <span class="k">return</span> <span class="n">양수</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">o1</span> <span class="o">&lt;</span> <span class="n">o2</span><span class="o">)</span> <span class="k">return</span> <span class="n">음수</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">o1</span> <span class="o">==</span> <span class="n">o2</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">){</span>
    <span class="c1">//...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div></ul></ul></ul></ul><p><br /> <br /></p><h2 id="ch04-스택과-큐"><span class="mr-2">Ch04. 스택과 큐</span><a href="#ch04-스택과-큐" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="04-1-스택"><span class="mr-2">04-1. 스택</span><a href="#04-1-스택" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>LIFO(Last In First Out)<li>스택에 데이터를 넣는 push와 데이터를 꺼내는 pop<li><p>push와 pop을 하는 위치를 꼭대기(top)이라고 하고, 스택의 가장 아랫 부분은 바닥(bottom)이라고 함.</p><li>자바에서는 메서드의 호출과 실행시 스택을 사용함. 다음은 메서드 호출 및 실행과정. <br /></ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="kt">void</span> <span class="nf">x</span><span class="o">(){}</span>
    <span class="kt">void</span> <span class="nf">y</span><span class="o">(){}</span>
    <span class="kt">void</span> <span class="nf">z</span><span class="o">(){</span>
      <span class="n">x</span><span class="o">();</span>
      <span class="n">y</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">main</span><span class="o">(){</span>
      <span class="n">z</span><span class="o">();</span>
    <span class="o">}</span>
</pre></table></code></div></div><blockquote><ol><li>push : main<li>push : z<li>push : x<li>pop : x<li>push : y<li>pop : y<li>pop : z<li>pop : main</ol></blockquote><ul><li>스택 만들기</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
</pre><td class="rouge-code"><pre>    <span class="kd">class</span> <span class="nc">MyStack</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;{</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">max</span><span class="o">;</span>    <span class="c1">//스택 용량</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">ptr</span><span class="o">;</span>    <span class="c1">//스택 포인터</span>
        <span class="kd">private</span> <span class="no">E</span><span class="o">[]</span> <span class="n">stk</span><span class="o">;</span>  <span class="c1">//스택 본체</span>

        <span class="kd">public</span> <span class="nf">MyStack</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
            <span class="k">try</span><span class="o">{</span>
                <span class="n">stk</span> <span class="o">=</span> <span class="o">(</span><span class="no">E</span><span class="o">[])</span><span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="n">max</span><span class="o">];</span>
            <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">OutOfMemoryError</span> <span class="n">e</span><span class="o">){</span>
                <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//push 메서드</span>
        <span class="kd">public</span> <span class="no">E</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ptr</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">OverflowMyStackException</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">stk</span><span class="o">[</span><span class="n">ptr</span><span class="o">++]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//pop 메서드</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">(){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ptr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">EmptyMyStackException</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">stk</span><span class="o">[--</span><span class="n">ptr</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="c1">//peek 메서드</span>
        <span class="kd">public</span> <span class="no">E</span> <span class="nf">peek</span><span class="o">(){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ptr</span> <span class="o">&lt;=</span><span class="mi">0</span> <span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">EmptyMyStackException</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">stk</span><span class="o">[</span><span class="n">ptr</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="c1">//indexOf 메서드 (top to bottom 선형 검색 수행)</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">indexOf</span><span class="o">(</span><span class="no">E</span> <span class="n">x</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ptr</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">stk</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//clear 메서드</span>
        <span class="c1">//스택의 모든 작업들은 스택 포인터(ptr)을 이용하여 이루어지기 때문에,</span>
        <span class="c1">//스택의 요솟값을 변경할 필요가 없다.</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">(){</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">}</span>
        <span class="c1">//capacity 메서드</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">capacity</span><span class="o">(){</span> <span class="k">return</span> <span class="n">max</span><span class="o">;</span> <span class="o">}</span>
        <span class="c1">//size 메서드</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(){</span> <span class="k">return</span> <span class="n">ptr</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="o">}</span>
        <span class="c1">//IsEmpty 메서드</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">IsEmpty</span><span class="o">(){</span> <span class="k">return</span> <span class="n">ptr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">}</span>
        <span class="c1">//IsFull 메서드</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">IsFull</span><span class="o">(){</span> <span class="k">return</span> <span class="n">ptr</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">;</span> <span class="o">}</span>
        <span class="c1">//dump 메서드 (스택의 모든 데이터 표시)</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dump</span><span class="o">(){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ptr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"스택이 비어있음."</span><span class="o">);</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ptr</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">stk</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>


    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">EmptyMyStackException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span><span class="o">{</span>
        <span class="kd">public</span> <span class="nf">EmptyMyStackException</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">OverflowMyStackException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span><span class="o">{</span>
        <span class="kd">public</span> <span class="nf">OverflowMyStackException</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></table></code></div></div><p><br /></p><h3 id="04-2-큐"><span class="mr-2">04-2. 큐</span><a href="#04-2-큐" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>FIFO(First In First Out)<li>큐에 데이터를 넣는 인큐(enqueue), 데이터를 꺼내는 디큐(dequeue), 데이터를 꺼내는 쪽인 프런트(front), 데이터를 넣는 쪽인 리어(rear)<li>인큐의 경우 복잡도는 O(1), 디큐의 경우 복잡도는 O(n). 데이터를 꺼내고 다음 두 번째 요소부터 이후의 요소를 모두 앞으로 옮겨야 하기 때문.<li><p>링 버퍼(배열 요소를 앞으로 옮기지 않도록 하는 큐) 이용시에는 디큐시에도 복잡도 O(1)</p><li>배열을 이용해 큐 구현</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
</pre><td class="rouge-code"><pre><span class="c1">//해당 예제는 dequeue시 앞으로 옮기는 작업 없도록 구현.(링버퍼)</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyQueue</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">max</span><span class="o">;</span>    <span class="c1">//큐의 용량</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">front</span><span class="o">;</span>  <span class="c1">//맨 앞의 커서</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">rear</span><span class="o">;</span>   <span class="c1">//맨 뒤의 커서</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">num</span><span class="o">;</span>    <span class="c1">//현재의 데이터 수</span>
    <span class="kd">private</span> <span class="no">E</span><span class="o">[]</span> <span class="n">que</span><span class="o">;</span>    <span class="c1">//큐의 본체</span>

    <span class="kd">class</span> <span class="nc">EmptyMyQueueException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span><span class="o">{</span>
      <span class="kd">public</span> <span class="nf">EmptyMyQueueException</span><span class="o">(){}</span>
    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">OverflowMyQueueException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span><span class="o">{</span>
      <span class="kd">public</span> <span class="nf">OverflowMyQueueException</span><span class="o">(){}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">MyQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">){</span>
      <span class="n">num</span> <span class="o">=</span> <span class="n">front</span> <span class="o">=</span> <span class="n">rear</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="n">max</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>

      <span class="k">try</span><span class="o">{</span>
        <span class="n">que</span> <span class="o">=</span> <span class="o">(</span><span class="no">E</span><span class="o">[])</span><span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="n">max</span><span class="o">];</span>
      <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">OutofMemoryError</span> <span class="n">e</span><span class="o">){</span>
        <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="no">E</span> <span class="nf">enqueue</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">)</span>  <span class="k">throw</span> <span class="k">new</span> <span class="nc">OverflowMyQueueException</span><span class="o">();</span>
      <span class="n">que</span><span class="o">[</span><span class="n">rear</span><span class="o">++]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
      <span class="n">num</span><span class="o">++;</span>
      <span class="k">if</span><span class="o">(</span><span class="n">rear</span> <span class="o">==</span> <span class="n">max</span><span class="o">)</span> <span class="n">rear</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="no">E</span> <span class="nf">dequeue</span><span class="o">(){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">num</span><span class="o">&lt;=</span><span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">EmptyMyQueueException</span><span class="o">();</span>
      <span class="no">E</span> <span class="n">e</span> <span class="o">=</span> <span class="n">que</span><span class="o">[</span><span class="n">front</span><span class="o">++];</span>
      <span class="n">num</span><span class="o">--;</span>
      <span class="k">if</span><span class="o">(</span><span class="n">front</span> <span class="o">==</span> <span class="n">max</span><span class="o">)</span> <span class="n">front</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//큐에서 데이터를 피크</span>
    <span class="kd">public</span> <span class="no">E</span> <span class="nf">peek</span><span class="o">(){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">num</span><span class="o">&lt;=</span><span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">EmptyMyQueueException</span><span class="o">();</span>
      <span class="k">return</span> <span class="n">que</span><span class="o">[</span><span class="n">front</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="c1">//indexOf</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">indexOf</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">){</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">num</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">front</span><span class="o">)</span> <span class="o">%</span> <span class="n">max</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">que</span><span class="o">[</span><span class="n">idx</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">e</span><span class="o">))</span> <span class="k">return</span> <span class="n">idx</span><span class="o">;</span>  <span class="c1">//검색 성공</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>  <span class="c1">//검색 실패</span>
    <span class="o">}</span>

    <span class="c1">//clear</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">(){</span>
      <span class="n">num</span> <span class="o">=</span> <span class="n">front</span> <span class="o">=</span> <span class="n">rear</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//capacity</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">capacity</span><span class="o">(){</span>
      <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//size</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(){</span>
      <span class="k">return</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//isEmpty</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">(){</span>
      <span class="k">return</span> <span class="n">num</span><span class="o">&lt;=</span><span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//isFull</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isFull</span><span class="o">(){</span>
      <span class="k">return</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//dump</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dump</span><span class="o">(){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">num</span><span class="o">&lt;=</span><span class="mi">0</span><span class="o">)</span>  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"큐가 비었습니다."</span><span class="o">);</span>
      <span class="k">else</span><span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">num</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">que</span><span class="o">[(</span><span class="n">i</span><span class="o">+</span><span class="n">front</span><span class="o">)%</span><span class="n">max</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>  
      <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">//search</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">){</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">num</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">que</span><span class="o">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">front</span><span class="o">)</span> <span class="o">%</span> <span class="n">max</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">e</span><span class="o">))</span> <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
</pre></table></code></div></div><p><br /><br /></p><h2 id="ch05-재귀-알고리즘"><span class="mr-2">Ch05. 재귀 알고리즘</span><a href="#ch05-재귀-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="05-1-재귀의-기본"><span class="mr-2">05-1. 재귀의 기본</span><a href="#05-1-재귀의-기본" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>재귀란?</p><p>어떤 사건이 자기 자신을 포함하고, 다시 자기 자신을 사용하여 정의되는 것을 의미함.</p><p>재귀의 특징을 이용하여 어떠한 문제가 있을 경우 해당 문제를 부분적으로 쪼개 해결하는 것이 가능함.</p><p>1부터 n까지의 곱을 구해야 하는 경우(팩토리얼), 4!은 4 * 3!이므로 n!은 n*(n-1)!과 같다.</p><p>이런 식으로 수학에서의 귀납법 원리를 이용하여 문제를 해결할 수 있다.</p><ul><li>재귀 알고리즘의 이해를 위해선 <strong>선언형 프로그래밍</strong>과 <strong>명령형 프로그래밍</strong>의 차이를 이해하는 것이 필요.<ul><li>우선 명령형 프로그래밍은 알고리즘을 명시하고 목표를 명시하지 않음.<li>하지만 선언형 프로그래밍은 목표를 명시하고 알고리즘은 명시하지 않음.<ul><li>목표를 명시한다는 것은 <strong>문제를 명확하게 정의</strong>하고 적절한 <strong>종료조건이 설정되어야</strong> 한다는 것.</ul><li>예를 들어서 팩토리얼 함수를 구현할 때, 명령형 프로그래밍에 의하면 어떠한 값이 나오는지가 아니라, n부터 1까지를 곱하는 알고리즘을 작성하게 되고,<li>선언형 프로그래밍에 따르면 n의 팩토리얼은 n이 1일때 종료되며 n!은 n*(n-1)!으로 문제를 정의하게 됨.</ul></ul><li>예시(팩토리얼)<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">factorial</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">NFactorial</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">n</span><span class="o">*</span><span class="nc">NFactorial</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>  <span class="c1">//재귀 호출.</span>
    <span class="k">else</span>  <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><li><p>직접 재귀와 간접 재귀</p><p>위의 예시처럼 자신과 같은 메서드를 호출하면 직접 재귀,</p><p>다른 메서드를 거쳐 다시 자신을 호출하게 되면 간접재귀.(ex. a에서 b를 호출하고 b에서 다시 a를 호출)</p><li><p>유클리드 호제법</p><p>최대공약수를 구하는 알고리즘. 두 정수가 있을 때, 큰 값을 작은 값으로 나누어 떨어지는 가장 작은 값.</p><p>호제법이란 말은 두 수가 서로 상대방 수를 나누어 원하는 수를 얻는 알고리즘을 의미함.</p><p>2개의 자연수 a, b에 대해 a를 b로 나눈 나머지를 r이라 하면(단, a&gt;b) a와 b의 최대 공약수는 b와 r의 최대 공약수와 같음. 이러한 성질에 따라 다시 b를 r로 나눈 나머지 r1을 구하고, 다시 r을 r1으로 나눈 나머지를 구하는 과정을 반복해 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대 공약수이다.</p><ul><li>ex1) 22와 8<ul><li>22 % 8 = 6<li>8 % 6 = 2<li>6 % 2 = 0<li>최대 공약수는 마지막에 나눈 수인 2</ul><li>ex2) 1071과 1029<ul><li>1071 % 1029 = 42<li>1029 % 42 = 21<li>42 % 21 = 0<li>최대 공약수는 마지막에 나눈 수인 21</ul></ul><li>이를 메서드로 구현해보면,<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>  <span class="kt">int</span> <span class="nf">gcd</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="o">);</span>
  <span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>  <span class="c1">//세 개 이상 수의 최대공약수 구하기</span>
  <span class="kt">int</span> <span class="nf">gcd</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">%</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">b</span><span class="o">;</span>
      <span class="k">else</span> <span class="k">return</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="kt">int</span> <span class="nf">arrGcd</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">return</span> <span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>

      <span class="k">return</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">],</span> <span class="n">arrGcd</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="o">));</span>
  <span class="o">}</span>
</pre></table></code></div></div></ul><p><br /></p><hr /><p><br /></p><h3 id="05-2-재귀-알고리즘-분석"><span class="mr-2">05-2. 재귀 알고리즘 분석</span><a href="#05-2-재귀-알고리즘-분석" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>하향식 분석<ul><li>가장 위쪽에 위치한 상자의 메서드 호출부터 시작해 계단식으로 자세히 조사하는 분석 기법.<li>처음 호출부터 스택을 쌓아가는 식</ul><li>상향식 분석<ul><li>아래쪽부터 쌓아 올리며 분석하는 방법.<li>실행 결과를 합쳐나가는 느낌.</ul><li>재귀 알고리즘의 비재귀적 표현<ul><li>재귀 함수 호출은 context switching으로 인한 오버헤드, 시스템 부하 등의 문제 발생 가능. 따라서 최종 최적화 단계에서는 대체로 비재귀적으로 변경.<li>TODO<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
</pre><td class="rouge-code"><pre><span class="c1">//재귀</span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">recur1</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
  <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
    <span class="n">recur1</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>     <span class="c1">//n을 n-1로 업데이트하고 메서드 재실행한다는 의미를 가짐.</span>
                    <span class="c1">//단, 다음 행에서 n을 그대로 출력해야 하므로 값을 임시로 저장해야 함.</span>
                    <span class="c1">//또한 n을 출력하기 전에 recur1(n-1)부터 실행해야 함.</span>
                    <span class="c1">//이러한 문제 해결에 효과적인 데이터 구조가 Stack.</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="n">recur1</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">);</span>     <span class="c1">//n을 n-2로 업데이트하고 메서드 재실행한다는 의미를 가짐.</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kt">void</span> <span class="nf">recur2</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
  <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
    <span class="n">recur2</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">recur2</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//====================================================================================</span>
<span class="c1">//비재귀</span>
<span class="kd">class</span> <span class="nc">IntStack</span><span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">max</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">ptr</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">stk</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">IntStack</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">max</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="n">stk</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">capacity</span><span class="o">];</span>
  <span class="o">}</span>
  <span class="c1">//pop, push 등 구현 생략...</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kt">void</span> <span class="nf">recur1_1</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
  <span class="nc">IntStack</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntStack</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

  <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
      <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

      <span class="c1">//출력 전에 n-1로 업데이트된 상태에서 재귀호출 해야함. -&gt; coninue</span>
      <span class="c1">//recur(n-1)은  n = n-1; continue;과 같음.</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
      <span class="k">continue</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">true</span><span class="o">){</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

      <span class="c1">//아래에선(꼬리재귀) recur(n-2)은  n = n-2; continue;과 같음.</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span>
      <span class="k">continue</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">break</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
 <span class="c1">//TODO ..</span>
 <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recur2_1</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">nstk</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100</span><span class="o">];</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">sstk</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100</span><span class="o">];</span>
  <span class="kt">int</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">sw</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

  <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
          <span class="n">ptr</span><span class="o">++;</span>
          <span class="n">nstk</span><span class="o">[</span><span class="n">ptr</span><span class="o">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
          <span class="n">sstk</span><span class="o">[</span><span class="n">ptr</span><span class="o">]</span> <span class="o">=</span> <span class="n">sw</span><span class="o">;</span>


          <span class="k">if</span><span class="o">(</span><span class="n">sw</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
              <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
          <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">sw</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
              <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span>
              <span class="n">sw</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
          <span class="o">}</span>
          <span class="k">continue</span><span class="o">;</span>
      <span class="o">}</span>

    <span class="k">do</span><span class="o">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">nstk</span><span class="o">[</span><span class="n">ptr</span><span class="o">];</span>
        <span class="n">sw</span> <span class="o">=</span> <span class="n">sstk</span><span class="o">[</span><span class="n">ptr</span><span class="o">--]+</span><span class="mi">1</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">sw</span> <span class="o">==</span> <span class="mi">2</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ptr</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span><span class="k">while</span><span class="o">(</span><span class="n">sw</span> <span class="o">==</span> <span class="mi">2</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div></ul></ul><p><br /></p><hr /><p><br /></p><h3 id="05-3-하노이의-탑"><span class="mr-2">05-3. 하노이의 탑</span><a href="#05-3-하노이의-탑" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>문제 정의 : 원반 1부터 n-1까지 겹친 상태를 하나의 그룹으로 보고, 원반 n을 시작 기둥에서 목표 기둥으로 옮긴 후, 나머지 그룹을 중간 기둥에서 목표 기둥으로 옮긴다. 단, 원반이 한개인 경우는 목표 기둥으로 곧바로 옮긴다.</p><li><p>종료 조건 : n이 1일때는 자기 자신을 호출할 필요 없다. 목표 기둥으로 곧바로 옮기면 된다.</p><li><p>실행 횟수 : n-1개의 원반을 옮기는 경우 실행 횟수를 A라고 했을 때,</p><ul><li>1부터 n-1까지의 원반 그룹을 중간 기둥으로 옮기는 횟수 A회,<li>n번째 원반을 목표 기둥으로 옮기는 횟수 1회,<li>1부터 n-1까지의 원반 그룹을 목표 기둥으로 옮기는 횟수 A회로 총 2A+1회이다.<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Hanoi</span><span class="o">{</span>
<span class="c1">//재귀</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
  <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span>
    <span class="c1">//기둥을 정수 1, 2, 3으로 표현했을 때, 중간 기둥은 목표 기둥과 시작 기둥을 제외한 나머지.</span>
    <span class="n">move</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="mi">6</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">);</span>
        
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"원반["</span><span class="o">+</span> <span class="n">n</span> <span class="o">+</span><span class="s">"]을"</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">"기둥에서 "</span><span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="s">"기둥으로 옮김."</span><span class="o">);</span>

  <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">move</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
    
<span class="o">}</span>

  <span class="c1">//비재귀</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">move_1</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
   <span class="kt">int</span><span class="o">[]</span> <span class="n">xstk</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">50</span><span class="o">];</span>
   <span class="kt">int</span><span class="o">[]</span> <span class="n">ystk</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">50</span><span class="o">];</span>
   <span class="kt">int</span><span class="o">[]</span> <span class="n">sstk</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">50</span><span class="o">];</span>
   <span class="kt">int</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">//스택 포인터</span>
   <span class="kt">int</span> <span class="n">sw</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

   <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
       <span class="k">if</span><span class="o">(</span><span class="n">sw</span><span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">){</span>
           <span class="n">xstk</span><span class="o">[</span><span class="n">ptr</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
           <span class="n">ystk</span><span class="o">[</span><span class="n">ptr</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
           <span class="n">sstk</span><span class="o">[</span><span class="n">ptr</span><span class="o">]</span> <span class="o">=</span> <span class="n">sw</span><span class="o">;</span>
           <span class="n">ptr</span><span class="o">++;</span>

           <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
           <span class="n">y</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">;</span>
           <span class="k">continue</span><span class="o">;</span>
       <span class="o">}</span>

       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%d 원반을 %d 기둥에서 %d 기둥으로 옮김.\n"</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>

       <span class="k">if</span><span class="o">(</span><span class="n">sw</span><span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">){</span>
           <span class="n">xstk</span><span class="o">[</span><span class="n">ptr</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
           <span class="n">ystk</span><span class="o">[</span><span class="n">ptr</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
           <span class="n">sstk</span><span class="o">[</span><span class="n">ptr</span><span class="o">]</span> <span class="o">=</span> <span class="n">sw</span><span class="o">;</span>
           <span class="n">ptr</span><span class="o">++;</span>

           <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
           <span class="n">x</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">;</span>
           <span class="k">if</span><span class="o">(++</span><span class="n">sw</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="n">sw</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
           <span class="k">continue</span><span class="o">;</span>
       <span class="o">}</span>

       <span class="k">do</span><span class="o">{</span>
           <span class="k">if</span><span class="o">(</span><span class="n">ptr</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
           <span class="n">x</span> <span class="o">=</span> <span class="n">xstk</span><span class="o">[</span><span class="n">ptr</span><span class="o">];</span>
           <span class="n">y</span> <span class="o">=</span> <span class="n">ystk</span><span class="o">[</span><span class="n">ptr</span><span class="o">];</span>
           <span class="n">sw</span> <span class="o">=</span> <span class="n">sstk</span><span class="o">[</span><span class="n">ptr</span><span class="o">]+</span><span class="mi">1</span><span class="o">;</span>
           <span class="n">n</span><span class="o">++;</span>
       <span class="o">}</span><span class="k">while</span><span class="o">(</span><span class="n">sw</span> <span class="o">==</span> <span class="mi">2</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div></ul></ul><h3 id="05-4-8퀸-문제"><span class="mr-2">05-4. 8퀸 문제</span><a href="#05-4-8퀸-문제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>8 * 8의 체스판에서 퀸이 서로를 공격해 잡을 수 없도록 배치하는 문제이다.<li><p>1단계, 2단계, 3단계로 나누어 해결해본다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EightQueen</span><span class="o">{</span>
  <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">pos</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">8</span><span class="o">];</span>
  <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">flag_a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">8</span><span class="o">];</span>
  <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">flag_b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">15</span><span class="o">];</span>
  <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">flag_c</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">15</span><span class="o">];</span>

  <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(){</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%2d"</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
  <span class="o">}</span>
      
<span class="cm">/*
  1단계. 각 열에 퀸을 1개만 배치한다.
  총 경우의 수 : 8^8 = 16,777,216
*/</span>
  <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setPos_1</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">){</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
      <span class="n">pos</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>         <span class="c1">//퀸을 i열의 j행에 배치한다.</span>

      <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">7</span><span class="o">)</span> <span class="n">print</span><span class="o">();</span> <span class="c1">//재귀호출을 반복하다가 i가 7이 되고, </span>
                          <span class="c1">//이는 8개의 퀸이 모두 배치된다는 것을 의미.</span>

      <span class="k">else</span>  <span class="nf">setPos_1</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span><span class="c1">//다음 열에 퀸을 배치한다.</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="cm">/*
    2단계. 1단계에서 각 행에 퀸을 1개만 배치한다.
    즉, 각 퀸은 모두 다른 행과 열에 배치되어야 한다.
    이는 boolean 배열인 flag_a를 이용한다. flag[j]는 j행에 퀸 배치여부를 관리한다.
        
    각 열에서 퀸이 배치되면, 고려해야 할 행이 하나씩 줄어드는 것이므로
    총 경우의 수 : 8! = 40320
  */</span>
  <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setPos_2</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">){</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
      <span class="k">if</span><span class="o">(!</span><span class="n">flag_a</span><span class="o">[</span><span class="n">j</span><span class="o">]){</span> <span class="c1">//j행에 퀸이 배치되지 않은 경우만 고려한다.</span>
        <span class="n">pos</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">7</span><span class="o">)</span> <span class="n">print</span><span class="o">();</span>
        <span class="k">else</span><span class="o">{</span>
          <span class="n">flag_a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">//8열을 제외한 나머지 열에서 </span>
                          <span class="c1">//j행에 퀸을 배치하였으므로 true로 바꿔준다.</span>
                          <span class="c1">//이렇게 하면 8열에서 loop문을 돌 때, j행은 고려하지 않는다.</span>
          <span class="n">setPos_2</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>

          <span class="n">flag_a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span><span class="c1">//재귀 호출한 setPos_2(i+1)메서드의 실행이 끝나면</span>
                            <span class="c1">//퀸의 배치를 옮겨서 다시 경우를 따지므로 false로 바꿔준다.</span>
        <span class="o">}</span>
      <span class="o">}</span>
          
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="cm">/*
    3단계. 마지막으로, 퀸은 대각선으로도 공격할 수 있으므로 
    배치하는 퀸의 우상향, 우하향 대각선 상에 다른 퀸이 존재하지 않아야 한다는 조건 추가

    flag_b와 flag_c는 각각 우상향, 우하향 대각선에 퀸 배치여부를 관리한다.
    b의 경우 우상향인데, 체스판에 대각선을 그어 0부터 14까지 넘버링을 하고,
     i+j로 해당 위치를 구할 수 있다.

    c의 경우 우하향인데 i - j + 7으로 구할 수 있다. 

    실행횟수 : 92
  */</span>
  <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setPos_3</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">){</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
      <span class="c1">//2단계에서 조건만 추가되었다.</span>
      <span class="k">if</span><span class="o">(!</span><span class="n">flag_a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">flag_b</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">flag_c</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">7</span><span class="o">]){</span>
        <span class="n">pos</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">7</span><span class="o">)</span> <span class="n">print</span><span class="o">();</span>
        <span class="k">else</span><span class="o">{</span>
          <span class="n">flag_a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">flag_b</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">flag_c</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">7</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span>
          <span class="nf">setPos_3</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
          <span class="n">flag_a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">flag_b</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">flag_c</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">7</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>    
</pre></table></code></div></div></ul><h2 id="ch06-정렬"><span class="mr-2">Ch06. 정렬</span><a href="#ch06-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="06-1-정렬"><span class="mr-2">06-1. 정렬</span><a href="#06-1-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p><strong>핵심 항목의 대소 관계</strong>에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업으로서 정렬 알고리즘은 <strong>교환, 선택, 삽입</strong>의 세 가지 핵심 요소 가짐.</p><li><p>정렬의 안정성</p><ul><li>안정성은 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지되는지 여부를 기준으로 판단.</ul></ul><p><br /></p><hr /><p><br /></p><h3 id="06-2-버블-정렬"><span class="mr-2">06-2. 버블 정렬</span><a href="#06-2-버블-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>이웃한 두 요소의 대소 관계를 비교하여 교환을 반복하는 방법.<li>n개의 요소를 가진 배열의 경우<ul><li>첫번째 패스에서는 n - 1회 비교, k번째 패스에서는 n - k회 비교.<li>모든 정렬이 끝나려면 패스는 n - 1회 수행되어야 함.<li>패스를 k회 수행하면 앞 or 뒤의 요소 k개가 정렬된 상태가 됨.<li>비교 횟수는 (n-1)회 + (n-2)회 + … + 1 = n*(n-1)/2회.<li>교환 횟수는 배열의 요솟값에 따라 달라지므로 평균값은 비교 횟수의 절반인 n*(n-1)/4.</ul><li><p>서로 이웃한 요소에 대해서만 교환하므로 안정적인 알고리즘임.</p><li>특징<ul><li>장점<ul><li>단순함.</ul><li>단점<ul><li>특정 요소가 적절한 위치에 있음에도 인접한 요소와의 대소관계만을 고려하기 때문에 교환이 이루어지는 상황 발생할 수 있음. 지나친 교환작업.</ul></ul><li>코드<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">//교환 메서드</span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx2</span><span class="o">){</span>
  <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">idx1</span><span class="o">];</span>
  <span class="n">a</span><span class="o">[</span><span class="n">idx1</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">idx2</span><span class="o">];</span>
  <span class="n">a</span><span class="o">[</span><span class="n">idx2</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">//정렬 메서드</span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">bubbleSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">--){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><li>알고리즘 개선<ul><li>n개의 요소를 가진 배열의 모든 정렬이 끝나려면 패스는 n-1회 수행되어야 하는데,<br /> 이미 정렬이 되어있는 경우에는 굳이 수행할 필요 없음.<li>반복문 안에서 교환 횟수가 0일 경우 정렬을 중단하는 방법(1), 혹은 마지막에 정렬을 수행한 위치를 기억하여 범위를 줄여나가는 방법(2)이 있음.<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bubbleSort_1</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
   <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
     <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
     <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
       <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]){</span>
         <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
         <span class="n">cnt</span><span class="o">++;</span>
       <span class="o">}</span>
     <span class="o">}</span>
     <span class="c1">//교환이 없다는 것은 정렬된 상태라는 것이므로 중단한다.</span>
     <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
   <span class="o">}</span>
 <span class="o">}</span>

 <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bubbleSort_2</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
   <span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
   <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
     <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
       <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]){</span>
         <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
         <span class="c1">//last의 값을 가장 마지막의 인덱스로 계속 갱신</span>
         <span class="n">last</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
       <span class="o">}</span>
     <span class="o">}</span>
     <span class="c1">//범위를 좁힌다.</span>
     <span class="n">i</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
   <span class="o">}</span>
 <span class="o">}</span>
</pre></table></code></div></div><li>정렬 과정에서 값은 한 칸씩 이동하므로, <br />최댓값이 맨 처음에 있는 경우나, 최솟값이 맨 마지막에 있는 경우에는 위의 두 방법이 무의미함.<ul><li>이러한 문제를 해결할 수 있는 알고리즘 : 양방향 버블정렬 = 칵테일 정렬 = 셰이커 정렬<li>패스를 수행할 때마다 방향을 바꾸어 정렬하는 알고리즘.<li>그림을 통해 이해하면 쉽다.</ul><p><img data-src="../../assets/img/shakerSort.gif" alt="칵테일 정렬(출처 : 위키백과 칵테일 정렬)" title="칵테일 정렬(출처 : 위키백과 칵테일 정렬)" data-proofer-ignore></p><ul><li>구현 코드<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">void</span> <span class="nf">shakerSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
  <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="k">while</span><span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
    <span class="c1">//왼 -&gt; 오</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">right</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]){</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>

    <span class="c1">//오 -&gt; 왼</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">right</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">left</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span><span class="c1">//(2)번 방법을 양방향으로 한다고 보면 될듯.</span>
</pre></table></code></div></div></ul></ul></ul><p><br /></p><hr /><p><br /></p><h3 id="06-3-단순-선택-정렬"><span class="mr-2">06-3. 단순 선택 정렬</span><a href="#06-3-단순-선택-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>가장 작은 요소부터 적절한 위치에 배치하여 정렬하는 알고리즘.<li>아직 정렬하지 않은 요소 중 가장 작은 값의 요소를 선택하고, 이 값을 정렬하지 않은 첫 번째 요소와 교체함.<li>제자리 정렬(추가 메모리 요하지 않음.)<li>특징<ul><li>장점<ul><li>비교횟수는 많은 대신 교환횟수가 적음. 따라서 교환횟수가 많이 요구되는 역순정렬에 유리함.</ul><li>단점<ul><li>매번 최솟값을 찾기 때문에 정렬을 위한 비교횟수가 많음.<li>서로 떨어져있는 요소를 교환하는 알고리즘이기 때문에 기존 배열 요소의 순서가 보장되지 않음. 안정적이지X.</ul></ul><li>구현<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">void</span> <span class="nf">selectionSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>  <span class="c1">//일단 정렬되지 않은 첫 번째 요소의 인덱스를 최솟값의 인덱스로 지정함.</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">min</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">min</span> <span class="o">=</span> <span class="n">j</span> <span class="c1">//반복문 돌며, 정렬되지 않은 요소중 최솟값을 찾는 과정</span>
    <span class="o">}</span>
    <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">min</span><span class="o">);</span>  <span class="c1">//교환</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div></ul><p><br /></p><hr /><p><br /></p><h3 id="06-4-단순-삽입-정렬"><span class="mr-2">06-4. 단순 삽입 정렬</span><a href="#06-4-단순-삽입-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>단순 선택 정렬은 최솟값을 찾아 맨 앞부터 교환해나가는 알고리즘이었다면,<br /> 단순 삽입 정렬은 정렬되지 않은 요소 중 첫 번째 요소를 정렬된 부분의 적절한 위치를 <strong>찾아서</strong> 끼워넣는 것.<li>떨어져 있는 요소들이 서로 뒤바뀌지 않기 때문에 안정적인 정렬.<li>특징<ul><li>장점<ul><li>최선의 경우(교환 없이 비교만 이루어지는 경우-&gt;내부 반복문은 수행되지 않음. n-1회의 비교만을 수행) O(N)의 시간복잡도를 가짐.<li>요소의 개수가 적거나 정렬상태에 가까울수록 효율적임.</ul><li>단점<ul><li>요소의 개수가 많을 경우 비효율적.</ul></ul><li>구현<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">void</span> <span class="nf">insertionSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
  <span class="c1">//맨 첫번째 요소(a[0])는 정렬되어 있는 것으로 간주. i=1부터</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="kt">int</span> <span class="n">j</span><span class="o">;</span>
    <span class="c1">//정렬할 대상은 a[i]. 정렬되지 않은 부분의 첫 요소</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="c1">//정렬되지 않은 첫 요소의 인덱스부터 시작한다.</span>
    <span class="c1">//앞의 요소가 정렬 대상 요소보다 크다면</span>
    <span class="k">for</span><span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">tmp</span><span class="o">;</span> <span class="n">j</span><span class="o">--){</span>
      <span class="c1">//뒤로 땡긴다.</span>
      <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>  
    <span class="o">}</span><span class="c1">//배열의 맨 앞까지 도달(정렬 대상보다 작은 요소가 없는 경우)하거나</span>
    <span class="c1">//정렬 대상 요소보다 작거나 같은 값이 존재하는 경우에는</span>
    <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span> <span class="c1">//값 삽입.</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><li>보초법을 이용한 단순 삽입 정렬<ul><li>보초법은 <a href="http://127.0.0.1:4000/posts/algoritm/#03-2-%EC%84%A0%ED%98%95-%EA%B2%80%EC%83%89linear-search">선형검색</a> 파트에서 다뤘었음.<br /> 검색 목표 값을 배열 후단에 추가하여 검색 실패시의 조건(인덱스가 끝까지 다다랐을 경우)을 생략할 수 있도록 하는 방법.<li><p>단순 삽입 정렬에서 j가 0보다 클 때를 조건에서 제하기 위해 배열 첫 요소에 tmp값을 계속 넣어주면 j가 0보다 크고 a[j-1]의 값이 tmp 값보다 클 때라는 두 가지 조건을 하나로 줄일 수 있음.</p><li>구현<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">void</span> <span class="nf">selectionSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>  <span class="c1">//a[i]의 값은 정렬을 위해 삽입할 값이며 위치 탐색의 종료 조건으로서 a[0]에 세팅.</span>

    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

    <span class="k">while</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]&gt;</span><span class="n">tmp</span><span class="o">){</span>  <span class="c1">//기존에는 j가 양수인 경우까지 따져줘야 했으나, 보초법을 통해 조건 하나를 제할 수 있음.</span>
      <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
      <span class="n">j</span><span class="o">--;</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div></ul><li>이진 검색을 이용한 단순 삽입 정렬<ul><li>단순 삽입 정렬은 요소 수가 많아질 수록 비교와 대입을 위한 비용이 커짐<li>단순 삽입 정렬은 특성상 정렬된 부분과 정렬되지 않은 부분으로 나뉘고, 정렬된 배열에 대해 이진 검색이 가능하므로 이를 활용하여 효율적으로 정렬시킬 수 있음.</ul><li>구현<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">void</span> <span class="nf">selectionSortBinary</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="c1">//정렬된 부분으로 검색 범위 제한</span>
    <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">c</span><span class="o">;</span>

    <span class="k">do</span><span class="o">{</span>
      <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>

      <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
      <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">)</span> <span class="n">l</span> <span class="o">=</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
      <span class="k">else</span> <span class="n">r</span> <span class="o">=</span> <span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span><span class="k">while</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">);</span>

    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">)</span> <span class="o">?</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span> <span class="o">:</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="c1">//한 칸씩 시프팅</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">idx</span><span class="o">;</span> <span class="n">j</span><span class="o">--){</span>
      <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="c1">//멈춘 위치에서 key값 대입.</span>
    <span class="n">a</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><br /></p></ul><hr /><p><br /></p><h3 id="06-5-셸-정렬"><span class="mr-2">06-5. 셸 정렬</span><a href="#06-5-셸-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>단순 삽입 정렬은 정렬되지 않은 요소가 적절한 위치에서 멀리 떨어져있을 경우 적절한 위치부터 해당 요소의 앞까지 모두 시프팅을 해야한다는 단점이 있음.<li>셸 정렬은 정렬할 배열의 요소를 몇 개의 그룹으로 나누어 그룹별로 단순 삽입 정렬을 수행하고, 그룹을 합쳐가며 정렬해나간다. 이러면 배열은 <strong>정렬된 상태에 가까워짐</strong><li>특징<ul><li>장점<ul><li>셸 정렬에 의하면 정렬해야 하는 횟수는 늘지만, 요소 이동의 횟수는 줄어듬.(삽입정렬 보완)</ul><li>단점<ul><li>간격 설정이 효율적이지 못할 경우 성능이 저하될 수 있음.</ul></ul><li>구현<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">void</span> <span class="nf">shellSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
  <span class="c1">//셸 정렬은 간격을 기준으로 배열을 부분 배열로 나누는데, </span>
  <span class="c1">//간격은 일단 배열 길이를 2로 나누어 가며 사용함.</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">interval</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span> <span class="n">interval</span><span class="o">&gt;=</span><span class="mi">1</span><span class="o">;</span> <span class="n">interval</span><span class="o">/=</span><span class="mi">2</span><span class="o">){</span>
    <span class="c1">//비교 및 요소 이동 로직은 삽입 정렬과 동일하나,</span>
    <span class="c1">//차이는 비교하는 두 요소가 붙어있는 것이 아니라 interval만큼 떨어져있음.</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">interval</span><span class="o">;</span> <span class="n">start</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">start</span><span class="o">++){</span>
      <span class="kt">int</span> <span class="n">j</span><span class="o">;</span>
      <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
      <span class="k">for</span><span class="o">(</span><span class="n">j</span><span class="o">=</span><span class="n">start</span><span class="o">;</span> <span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="n">interval</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">key</span><span class="o">;</span> <span class="n">j</span><span class="o">-=</span><span class="n">interval</span><span class="o">){</span>
        <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="n">interval</span><span class="o">];</span>
      <span class="o">}</span>
      <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
    <span class="o">}</span>

  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><li>효율적인 간격?<ul><li>셸 정렬을 위한 간격은 너무 적으면 속도가 느리고, 간격이 너무 많으면 오버헤드가 발생한다. 때문에 다양한 정형화된 간격이 존재하는 것 같은데, 해당 교재에서는 1, 4, 13, 40, 121, … 즉 전 항에 3을 곱하고 1을 더한 수열을 제시한다. 또한 오버헤드가 발생하지 않도록 간격이 배열의 요소수를 9로 나눈 몫을 넘지 않도록 한다.<li>정리하자면 n을 요솟수라고 하였을 때,<ul><li>i(x+1) = i(x)*3+1<li>간격 &lt; n/9</ul></ul><li>구현<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">void</span> <span class="nf">shellSort_v2</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
      <span class="kt">int</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
      <span class="k">for</span><span class="o">(;</span> <span class="n">interval</span><span class="o">&lt;</span><span class="n">n</span><span class="o">/</span><span class="mi">9</span><span class="o">;</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="o">){}</span>
        
      <span class="k">for</span><span class="o">(;</span> <span class="n">interval</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">;</span> <span class="n">interval</span><span class="o">/=</span><span class="mi">3</span><span class="o">){</span>
          <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">=</span><span class="n">interval</span><span class="o">;</span> <span class="n">start</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">start</span><span class="o">++){</span>
              <span class="kt">int</span> <span class="n">j</span><span class="o">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
                
              <span class="k">for</span><span class="o">(</span><span class="n">j</span><span class="o">=</span><span class="n">start</span><span class="o">-</span><span class="n">interval</span><span class="o">;</span> <span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">tmp</span><span class="o">;</span> <span class="n">j</span><span class="o">--){</span>
                  <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="n">interval</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
              <span class="o">}</span>
              <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="n">interval</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
          <span class="o">}</span>
      <span class="o">}</span>
  <span class="o">}</span>
</pre></table></code></div></div><p><br /></p></ul><hr /><p><br /></p><h3 id="06-6-퀵-정렬"><span class="mr-2">06-6. 퀵 정렬</span><a href="#06-6-퀵-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>정렬 속도가 매우 빠른</strong> 정렬 알고리즘 중 하나. 단, 요소의 수가 적으면 비효율적일 수 있다.<li>그룹의 요소 중 기준이 될 요소(피벗, 배열의 가운데 요소)을 하나 택하여 피벗을 기준으로 그룹을 나누고, 다시 피벗을 설정하고 그룹을 나누는 과정을 반복하는 정렬 알고리즘.(<strong>분할 정복 기법</strong>, <strong>재귀 호출</strong>)<li>특징<ul><li>장점<ul><li>별도의 추가적인 메모리를 사용하지 않아 제자리 정렬의 특징을 지닌다.</ul><li>단점<ul><li>서로 떨어진 요소들을 교환하기 때문에 안정적이지 않음<li>피벗을 잘못 설정할 경우 성능이 저하될 수 있음.</ul></ul><li><p>과정<br /> 1 : 왼-&gt;오 방향으로 피벗보다 큰 값의 요소를 찾을 때까지 진행하고(인덱스 l), <br /> 2 : 오-&gt;왼 방향으로 피벗보다 작은 값의 요소를 찾을 때까지 진행한다.(인덱스 r) <br /> 3 : 배열[l]과 배열[r]을 교환하며 위 과정을 l과 r이 교차할 때까지 계속 반복한다.<br /> 4 : l과 r이 교차하는 것이 아닌 같아지는 경우는 별도로 체크하지 않고 배열[l]과 배열[r]을 교환하는 무의미한 작업을 수행하도록 한다. 해당 문제를 교환으로 해결할 경우는 수행 횟수가 최대 1회에 그치지만, 조건으로 해결하고자 할 때에는 수행 횟수가 n회이기 때문.</p><li>구현<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">void</span> <span class="nf">partition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
  <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">];</span>

  <span class="k">do</span><span class="o">{</span>
    <span class="k">while</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">]&lt;</span><span class="n">pivot</span><span class="o">)</span> <span class="n">l</span><span class="o">++;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">r</span><span class="o">]&gt;</span><span class="n">pivot</span><span class="o">)</span> <span class="n">r</span><span class="o">--;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">pl</span><span class="o">&lt;=</span><span class="n">pr</span><span class="o">)</span> <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">l</span><span class="o">++,</span> <span class="n">r</span><span class="o">--);</span> <span class="c1">//교환 하고 다음부터 진행하도록 증감연산자 사용.</span>
  <span class="o">}</span><span class="k">while</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><li>퀵 정렬은 분할 정렬 알고리즘이므로, 위의 partion 메서드를 토대로 재귀 호출을 통해 퀵 정렬을 구현할 수 있음.<ul><li>재귀 호출 할 것이므로 <strong>종료 조건</strong>을 명확히 해야 한다. 그런데 이 알고리즘은 재귀 호출하는 과정에서 최소한 피벗은 위치가 정해지기 때문에 종료 조건이 명확함.</ul><li>구현(재귀)<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">void</span> <span class="nf">quickSort_recursive</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
  <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">a</span><span class="o">[(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)/</span><span class="mi">2</span><span class="o">];</span>

  <span class="k">do</span><span class="o">{</span>
    <span class="k">while</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="n">l</span><span class="o">++;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="n">r</span><span class="o">--;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">)</span> <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">l</span><span class="o">++,</span> <span class="n">r</span><span class="o">--);</span>
  <span class="o">}</span><span class="k">while</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">);</span>
    
  <span class="c1">////////////////재귀 호출////////////////</span>
  <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">r</span><span class="o">)</span> <span class="n">quickSort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
  <span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">&gt;</span><span class="n">l</span><span class="o">)</span> <span class="n">quickSort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
  <span class="c1">////////////////////////////////////////</span>
<span class="o">}</span>
</pre></table></code></div></div><li><p>위의 루프 부분에서 l과 r은 교차하게 되고, <br />왼쪽 그룹에 대한 퀵 정렬을 위해 right의 인자값으로 r을, <br />오른쪽 그룹에 대한 퀵 정렬을 위해 left의 인자값으로 l을 넘겨준다. <br />그룹의 요소가 하나만 남았을 때는 더 이상 정렬할 필요가 없기 때문에 각 그룹의 재귀 호출에 대해 조건을 걸어준다. (요소가 하나만 남았을 경우 left와 r은 같을 것이므로 조건이 거짓이고 따라서 탈출. l과 right의 경우도 마찬가지.)</p><li>구현(비재귀)<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">void</span> <span class="nf">quickSort_non_recursive</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
  <span class="c1">//좌 우로 나뉘는 그룹의 인덱스를 기억할 스택.</span>
  <span class="c1">//lStk에는 그룹의 첫번째 인덱스를, rStk에는 그룹의 끝 인덱스를 저장한다.</span>
  <span class="nc">Stack</span> <span class="n">lStk</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="nc">Stack</span> <span class="n">rStk</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

  <span class="n">lStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
  <span class="n">rStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>

  <span class="k">while</span><span class="o">(!</span><span class="n">lStk</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lStk</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="n">rStk</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">a</span><span class="o">[(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)/</span><span class="mi">2</span><span class="o">];</span>
  
    <span class="k">do</span><span class="o">{</span>
      <span class="k">while</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="n">l</span><span class="o">++;</span>
      <span class="k">while</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="n">r</span><span class="o">--;</span>
      <span class="k">if</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">)</span> <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">l</span><span class="o">++,</span> <span class="n">r</span><span class="o">--);</span>
    <span class="o">}</span><span class="k">while</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">);</span>

    <span class="k">if</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">right</span><span class="o">){</span>
      <span class="n">lStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
      <span class="n">rStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">r</span><span class="o">&gt;</span><span class="n">left</span><span class="o">){</span>
      <span class="n">lStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
      <span class="n">rStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><li>스택의 크기<ul><li>피벗을 기준으로 나뉘는 두 그룹의 요소의 개수는 차이가 있을 수 있다. 이에 착안하여 스택에 push하는 순서를 지정함으로써 퀵 정렬에 사용할 스택의 크기를 작게 할 수 있다.<ul><li>예를 들어 나뉜 두 그룹중 요소의 개수가 적은 그룹 x와 많은 그룹 y가 있을 때, x의 인덱스를 먼저 push한다면 나중에 push되는 y의 인덱스가 먼저 pop되어 y부터 정렬이 시작된다. 당연히 요소의 수가 적을수록 적은 횟수의 분할로 정렬을 마무리 할 수 있으므로 스택에 동시에 쌓이는 데이터의 수도 적음.<li>위 방식대로 요소의 수가 적은 그룹부터 정렬을 해나가도록 하면 전체 배열의 요수 수가 n개라고 할 때, 스택에 쌓이는 데이터의 최대 개수는 log n에 불과하다.(?)<li>요소 수가 더 많은 부분 배열을 먼저 푸쉬하고 요소 수가 적은 배열을 나중에 푸쉬하도록 left와 pr, pl과 right의 차이를 대소비교 하고, 조건식을 통해 순서를 제어한다.</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">//처리 순서를 조건에 따라 직접 지정하는 것보다 변수를 교체해주는 편이 간결함.</span>
 <span class="k">if</span><span class="o">(</span><span class="n">pr</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span> <span class="o">-</span> <span class="n">pl</span><span class="o">){</span>
   <span class="kt">int</span> <span class="n">tmp</span><span class="o">;</span>
   <span class="n">tmp</span> <span class="o">=</span> <span class="n">pr</span><span class="o">;</span>
   <span class="n">pr</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
   <span class="n">right</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>

   <span class="n">tmp</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
   <span class="n">left</span> <span class="o">=</span> <span class="n">pl</span><span class="o">;</span>
   <span class="n">pl</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
 <span class="o">}</span>

 <span class="k">if</span><span class="o">(</span><span class="n">right</span> <span class="o">&gt;</span> <span class="n">pl</span><span class="o">){</span>
   <span class="n">lStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">pl</span><span class="o">);</span>
   <span class="n">rStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="k">if</span><span class="o">(</span><span class="n">pr</span> <span class="o">&gt;</span> <span class="n">left</span><span class="o">){</span>
   <span class="n">lStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
   <span class="n">rStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">pr</span><span class="o">);</span>
 <span class="o">}</span>
</pre></table></code></div></div></ul><li>피벗의 선정<ul><li>퀵 정렬은 피벗을 기준으로 배열을 각 그룹으로 분할하고 정렬하는 과정을 반복하는 알고리즘이기 때문에, 피벗 선정에 있어서 한 쪽으로 치우치게 되면 효율적인 정렬을 기대할 수 없음.<li>안정적이고 효율적인 정렬을 위해선 배열의 중앙값을 피벗으로 선정하면 되지만, 배열 전체에 대해 이러한 작업을 수행하는 것은 지나치기 때문에 제시되는 방법 두 가지가 존재.<ul><li>첫번째, 나눌 배열의 요소의 개수가 3개 이상이면, 임의의 세 개의 요소를 선택하고 그 중 중앙값인 요소를 피벗으로 선정한다.<li>두번째, 나눌 배열의 처음, 가운데, 끝 요소를 정렬한 다음 가운데 요소와 끝에서 두 번째 요소를 교환하여 나눌 범위를 축소한다.(기존에는 스캔 범위가 left ~ right였으나, 해당 과정을 거친 후에는 left+1 ~ right-2로 축소됨.)</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">sortMedain</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">z</span><span class="o">){</span>
   <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">y</span><span class="o">])</span> <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
   <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">y</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">z</span><span class="o">])</span> <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">);</span>
   <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">y</span><span class="o">])</span> <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
   <span class="k">return</span> <span class="n">y</span><span class="o">;</span>
 <span class="o">}</span>

 <span class="kd">static</span> <span class="kt">void</span> <span class="nf">quickSort_non_recursive</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
   <span class="nc">Stack</span> <span class="n">lStk</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
   <span class="nc">Stack</span> <span class="n">rStk</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

   <span class="n">lStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
   <span class="n">rStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>

   <span class="k">while</span><span class="o">(!</span><span class="n">lStk</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
     <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">left</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">lStk</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
     <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">rStk</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
     <span class="c1">//중앙값의 인덱스를 구해</span>
     <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">sortMedain</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="o">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="o">)/</span><span class="mi">2</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
     <span class="c1">//해당 인덱스의 요소를 피벗으로 지정.</span>
     <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">m</span><span class="o">];</span>
     <span class="c1">//피벗을 배열의 맨 뒤에서 두번째 요소와 교체</span>
     <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
     <span class="c1">//스캔범위 축소</span>
     <span class="n">l</span><span class="o">++;</span>
     <span class="n">r</span><span class="o">-=</span><span class="mi">2</span><span class="o">;</span>
     <span class="c1">//첫 번째 방법은 피벗을 중간값으로 구해주기만 하면 됨.</span>
     <span class="k">do</span><span class="o">{</span>
       <span class="k">while</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="n">l</span><span class="o">++;</span>
       <span class="k">while</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="n">r</span><span class="o">--;</span>
       <span class="k">if</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">)</span> <span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">l</span><span class="o">++,</span> <span class="n">r</span><span class="o">--);</span>
     <span class="o">}</span><span class="k">while</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">);</span>

     <span class="k">if</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">right</span><span class="o">){</span>
       <span class="n">lStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
       <span class="n">rStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
     <span class="o">}</span>
     <span class="k">if</span><span class="o">(</span><span class="n">r</span><span class="o">&gt;</span><span class="n">left</span><span class="o">){</span>
       <span class="n">lStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
       <span class="n">rStk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
     <span class="o">}</span>
   <span class="o">}</span>

 <span class="o">}</span>
</pre></table></code></div></div></ul></ul><p><br /></p><hr /><p><br /></p><h3 id="06-7-병합-정렬"><span class="mr-2">06-7. 병합 정렬</span><a href="#06-7-병합-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>배열을 앞부분과 뒷부분으로 나누어 각각 정렬한 다음 병합하는 작업을 반복적으로 수행하여 정렬하는 알고리즘.<li>분할 정복 알고리즘<li>과정<ul><li>배열을 반으로 나누어 2개의 부분 배열로 분할함<li>부분 배열을 정렬하되, 부분 배열의 크기가 충분히 작지 않으면 재귀 호출.<ul><li>정렬 과정에서 앞 부분의 배열을 별도의 공간에 저장하고, 뒷 부분과 대소 비교(제자리 정렬 아님.)<li>Linked List로 구성된 레코드에 대해 병합 정렬 수행할 경우 제자리 정렬로 구현 가능. 매우 효율적</ul><li>정렬된 부분 배열을 병합</ul><li>특징<ul><li>장점<ul><li>퀵정렬과 달리 항상 절반으로 분할하기 때문에 분할 기준에 따른 성능 저하가 없음.</ul><li>단점<ul><li>추가적인 메모리가 요구됨.</ul></ul><li>구현<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre>  <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">buffer</span><span class="o">;</span>

  <span class="kd">static</span> <span class="kt">void</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="n">__mergeSort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">static</span> <span class="kt">void</span> <span class="nf">__mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
      <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">center</span><span class="o">;</span>
      <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="n">k</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
      <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="n">center</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>

      <span class="c1">//분할</span>
      <span class="n">__mergeSort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">center</span><span class="o">);</span>   
      <span class="n">__mergeSort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">center</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>

      <span class="c1">//정렬 및 합병</span>
      <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">center</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="c1">//별도 공간에 배열 앞 부분 복사</span>
          <span class="n">buffer</span><span class="o">[</span><span class="n">l</span><span class="o">++]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        
      <span class="c1">//(1)</span>
      <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">)</span> <span class="c1">//대소 비교하여 작은 값을 배열의 앞 부분부터 채움</span>
          <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="n">buffer</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">?</span> <span class="n">buffer</span><span class="o">[</span><span class="n">j</span><span class="o">++]</span> <span class="o">:</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
        
      <span class="c1">//(2)</span>
      <span class="k">while</span><span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">)</span>  <span class="c1">//buff에 남아있는 요소가 있다면 배열 a에 복사.</span>
          <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">++]</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
    <span class="o">}</span>
  <span class="o">}</span>
</pre></table></code></div></div><ul><li>Arrays 클래스의 정렬 메서드<ul><li>기본 자료형을 요소로 하는 배열의 정렬(Arrays.sort)메서드는 퀵 정렬 알고리즘 사용.<li>참조 자료형을 요소로 하는 배열의 정렬 메서드는 두 종류로 나눌 수 있음. 병합 정렬 알고리즘 사용.<ul><li>자연 정렬이 필요한 배열<ul><li>Comparable 인터페이스와 compateTo 메서드 구현</ul><li>자연 정렬이 필요하지 않은 배열<ul><li>Comparator 구현체를 매개변수로 전달.</ul></ul></ul></ul></ul><p><br /></p><hr /><p><br /></p><h3 id="06-8-힙-정렬"><span class="mr-2">06-8. 힙 정렬</span><a href="#06-8-힙-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p></p><h3 id="06-99-시간복잡도-비교"><span class="mr-2">06-99. 시간복잡도 비교</span><a href="#06-99-시간복잡도-비교" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://d2.naver.com/helloworld/0315536"><img data-src="../../assets/img/complexity.png" alt="" data-proofer-ignore></a></p><h2 id="reference"><span class="mr-2">Reference</span><a href="#reference" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Do it! 자료구조와 함께 배우는 알고리즘 입문 자바 편</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/algoritm/'>algoritm</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Algoritm+-+JaeHyeon&url=https%3A%2F%2Fjaehyeon-kim94.github.io%2Fposts%2Falgoritm%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Algoritm+-+JaeHyeon&u=https%3A%2F%2Fjaehyeon-kim94.github.io%2Fposts%2Falgoritm%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fjaehyeon-kim94.github.io%2Fposts%2Falgoritm%2F&text=Algoritm+-+JaeHyeon" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/RAID-LVM/">RAID와 LVM</a><li><a href="/posts/%ED%95%98%EB%93%9C/">하드 디스크 관리</a><li><a href="/posts/%EC%BB%A4%EB%84%90%EA%B3%BC-%EB%AA%A8%EB%93%88/">커널과 모듈</a><li><a href="/posts/%EB%A7%81%ED%81%AC/">링크</a><li><a href="/posts/CRON%EA%B3%BC-AT/">cron과 at</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hibernate/">hibernate</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/data-structure/">data structure</a> <a class="post-tag" href="/tags/authentication/">authentication</a> <a class="post-tag" href="/tags/authorization/">authorization</a> <a class="post-tag" href="/tags/chirpy/">chirpy</a> <a class="post-tag" href="/tags/jwt/">jwt</a> <a class="post-tag" href="/tags/oauth2/">oauth2</a> <a class="post-tag" href="/tags/security/">security</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%EC%88%9C%EC%84%9C%EB%8F%84/"><div class="card-body"> <em class="small" data-ts="1652626800" data-df="ll" > May 16, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>순서도</h3><div class="text-muted small"><p> 순서도 기호 Reference https://booksr.tistory.com/13</p></div></div></a></div><div class="card"> <a href="/posts/%ED%95%98%EB%93%9C/"><div class="card-body"> <em class="small" data-ts="1681052400" data-df="ll" > Apr 10, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>하드 디스크 관리</h3><div class="text-muted small"><p> 리눅스 디스크 파티션 마운트 포인트 설명   / 루트 파티션   /bin 기본 명령어   /sbin 시스템 관리용 명령어   ...</p></div></div></a></div><div class="card"> <a href="/posts/RAID-LVM/"><div class="card-body"> <em class="small" data-ts="1681052400" data-df="ll" > Apr 10, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>RAID와 LVM</h3><div class="text-muted small"><p> RAID와 LVM RAID RAID(Redundant Array of Inexpensive/Independent Disks)는 여러 디스크를 하나로 묶어 하나의 논리적 디스크로 작동하게 하는 것이다. RAID에는 하드웨어 방식과 소프트웨어 방식이 있는데 하드웨어 방식은 고비용, 고성능, 안정적이라는 특징을, 소프트웨어 방식은 저비용, 비교적 저...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Log4j2/" class="btn btn-outline-primary" prompt="Older"><p>Log4j2</p></a> <a href="/posts/printf/" class="btn btn-outline-primary" prompt="Newer"><p>Printf</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/username">JaeHyeon-Kim</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hibernate/">hibernate</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/data-structure/">data structure</a> <a class="post-tag" href="/tags/authentication/">authentication</a> <a class="post-tag" href="/tags/authorization/">authorization</a> <a class="post-tag" href="/tags/chirpy/">chirpy</a> <a class="post-tag" href="/tags/jwt/">jwt</a> <a class="post-tag" href="/tags/oauth2/">oauth2</a> <a class="post-tag" href="/tags/security/">security</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
