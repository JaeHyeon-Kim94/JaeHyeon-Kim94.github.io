---
categories: [algoritm]
tags: []
---

## Ch01. 기본 알고리즘

- 구조적 프로그래밍(Structured Programming)
  - 하나의 입구와 하나의 출구를 가진 구성 요소만을 계층적으로 배치하여 프로그램을 구성하는 방식
  - 제어 흐름 : 순차, 선택, 반복


- 드모르간 법칙
  - 각 조건을 부정하고 논리곱(AND)을 논리합(OR)으로, 논리합을 논리곱으로 바꾸고 다시 전체를 부정하면 원래의 조건과 같다는 법칙

<br>
<hr>
<br>

## Ch02. 기본 자료구조

- 다차원 배열 clone : 최상위의 1레벨만 수행하며, 그 아래 레벨의 배열은 참조를 공유한다.

<br>
<hr>
<br>

## Ch03. 검색

### 03-1 검색 알고리즘

***TODO***

> 1. 선형 검색 : 무작위로 늘어놓은 데이터 집합에서 검색 수행.
> 2. 이진 검색 : 일정한 규칙으로 늘어놓은 데이터 집합에서 아주 빠른 검색 수행.
> 3. 해시법 : 추가, 삭제가 자주 일어나는 데이터 집합에서 아주 빠른 검색 수행.
<br>&nbsp;&nbsp; - 체인법 : 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법
<br>&nbsp;&nbsp; - 오픈 주소법 : 데이터를 위한 해시 값이 충돌할 때 재해시 하는 방법

데이터의 집합에 대한 검색, 추가, 삭제 등의 작업에 소요되는 비용을 종합적으로 판단하여 알고리즘 선택해야 한다.

<br><br>

### 03-2 선형 검색(linear search)

- 직선으로 늘어선 요소들에 대해 검색을 할 때, 원하는 요소를 찾을 때까지 맨 앞부터 순차적으로 검색.
  -  선형 검색(linear search), 순차 검색 알고리즘(sequential search)
- 검색 종료 조건
  1. 검색 값을 발견하지 못하고 배열의 끝을 지나간 경우
  2. 검색할 값과 같은 요소를 발견한 경우

```java
    //선형 검색 while
    static int seqSearchW(int[] arr, int n, int key){
        while(true){
            if(i == n)      return -1;
            if(a[i]==key)   return i;

            i++;
        }
    }

    static int seqSearchF(int[] arr, int n, int key){
        for(int i=0; i<n; i++){
            if(a[i] == key) return i;

            return -1;
        }
    }
```

- 보초법

  - 선형 검색은 검색시 상기의 종료 조건 1, 2를 모두 판단하는데, 이 과정에서 소요되는 비용을 반으로 줄이는 방법.

  - 검색하고자 하는 요소값을 배열의 맨 마지막 요소로 넣는다. 이렇게 하면 종료조건 1을 무시하고 2만 판단하면 됨.

```java
static int seqSearchSen(int[] arr, int n, int key){
    int i=0;

    a[n] = key;
    while(true){
        if(a[i] == key) break;
        i++;
    }

    return i == n ? -1 : i;
}
```
***TODO***
- 판단 횟수 : 배열의 요솟수가 n개라면 평균 n/2회. 원하는 값이 배열에 존재하지 않는 경우 조건 1은 n+1, 2는 n회

### 03-3 이진 검색(binary search)

- 데이터가 키 값으로 이미 정렬되어 있어야 한다. 오름차순 혹은 내리마순으로 정렬된 배열에서 검색하는 알고리즘.
  
- linear search보다 검색이 좀 더 빠르다.
  
- 검색방식
  
  - 정렬된 배열의 정중앙 요소부터 검색을 시작한다. 해당 요소와 검색할 요소의 크기를 비교함으로써 범위가 반으로 줄어든다.
  
    - 오름차순으로 정렬된 배열을 기준으로, 검색 범위의 맨 앞 인덱스를 L, 맨 끝 인덱스를 R, 중앙을 C라고 할 때,
    - n개의 요소를 가진 배열의 검색 시작시 L 은 0, R은 n-1, C는 (n-1)/2로 초기화 되며
    - 배열[C] > key일때 검색 대상은 왼쪽 영역에 있는 것이 분명하므로, 배열[L] ~ 배열[C-1] 로 검색범위를 좁히며 R은 C-1로 업데이트 됨.
    - 반대로 배열[C] < key일때  검색범위는 배열[C+1] ~ 배열[R], L은 C+1
  
  - 해당 과정을 반복한다.
  - 검색 대상이 2개로 좁혀졌을 때에는 둘 중 앞의 값을 선택한다.


- 검색 종료 조건
  - 조건 1 : 배열[C]와 key가 일치하는 경우
  - 조건 2 : 검색 범위가 더이상 없는 경우
    - ex) L이 R보다 커지는 경우 혹은 R이 L보다 작아지는 경우

- 비교횟수
  - 평균값 : log n
  - 검색 실패시 log(n+1)회, 성공시 log n-1 회.

<br>
<hr>
<br>

