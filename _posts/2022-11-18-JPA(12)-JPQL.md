---
title : JPA(12)-JPQL
categories : [jpa]
tags: [jpa, hibernate]
---


# JPQL; Java Persistence Query Language

객체지향 쿼리 언어로서, 테이블을 대상으로 하는 SQL과 달리 엔티티 객체를 대상으로 쿼리한다.<br>
SQL을 추상화하여 DBMS에 독립적이며, 작성된 JPQL은 SQL로 변환되어 DBMS에 쿼리된다.

## 기본 문법

SQL처럼 SELECT, UPDATE, DELETE문을 사용할 수 있으나, persist 메서드로 커버되지 않는 기능이 없어서인지 INSERT문은 없다.

### SELECT문
 - SQL의 문법과 유사하나 <br>1) 클래스명이 아닌 엔티티 명을 사용한다는 점, <br>2) 엔티티와 속성에 한해선 대소문자를 구분한다는 점, <br>3) 별칭을 필수적으로 주어야 한다는 점 <br>세 가지 특징이 있다.

<br>


 - 쿼리 객체(TypeQuery, Query)

```java
String q = "SELECT m FROM Member m";
//두 번째 파라미터로 반환 타입을 명확하게 지정한 경우 TypeQuery를 반환하고,
TypedQuery<Member> tQuery = em.createQuery(q, Member.class);

// 지정하지 않아 반환 타입이 명확하지 않을 경우 Query를 반환한다.
// 프로젝션을 여러개 지정하면 TypeQuery는 사용할 수 없고 Query를 사용해야 한다.
// Query객체의 경우 SELECT절의 조회대상이 하나면 Object를, 둘 이상이면 Object[]를 반환한다.
q = "SELECT m.username, m.age FROM Member m"; 
Query query = em.createQuery(q)
```


<br>
 - 파라미터 바인딩<br>
JDBC의 경우 위치 기준 파라미터 바인딩만을 지원했다면, JPQL은 이름 기준 파라미터 바인딩도 지원한다.

   - SQL Injection 공격 예방을 위해선 SQL문에 파라미터를 직접 더하는게 아니라 파라미터 바인딩 메서드를 이용하자.
   - 파라미터 바인딩을 이용하면 JPA는 파라미터가 달라져도 같은 쿼리로 인식해 SQL로 파싱한 결과를 재사용할 수 있기 때문에 성능측면에서 효율적이므로 필수적으로 사용하도록 한다.

```java
String usernameParam = "User";

//이름 기준 파라미터 바인딩. 파라미터 앞에 :를 사용한다.

em.createQuery("SELECT m FROM Member m WHERE m.username = :username", Member.class);
  .setParameter("username", usernameParam);


//위치 기준 파라미터 바인딩. ?다음 위치값을 주면 된다.
em.createQuery("SELECT m FROM Member m WHERE m.username = ?1", Member.class);
  .setParameter(1, usernameParam);
```
<br>


 - 프로젝션
SELECT절에 조회할 대상을 지정하는 것을 프로젝션이라고 하며, <br>
프로젝션의 대상은 **엔티티**, **임베디드 타입**, **스칼라 타입**(숫자, 문자 등 기본 데이터 타입)이 있다.<br>


   - 엔티티 프로젝션
   ```java
    String memberq = "SELECT m FROM Member m";
    String teamq = "SELECT m.team FROM Member m";
   ```
   
   - 임베디드 타입 프로젝션
    ```java
      //임베디드 타입은 값에 불과하기 때문에 당연히 시작점이 될 수 없다. 
      String wrongq = "SELECT a FROM Addrss a"; //(X)

      //엔티티가 시작점이 되어야 한다.
      String rightq = "SELECT o.address FROM Order o";

      em.createQuery(rightq, Address.class);
    ```

    - 스칼라 타입 프로젝션
      ```java
        Double avg = 
            em.createQuery("SELECT AVG(o.orderAmount) FROM Order o", Double.class)
            .getSingleResult();
      ```


<br>
- NEW 명령어<br>
프로젝션이 여러개일 경우 Object[]가 반환되며 iteration을 통해 각 element를 casting해줘야 한다.<br>
또한 타입 지정도 되지 않으니 TypeQuery말고 Query를 사용해야 했다.<br>

  데이터가 단순하다면 모르겠지만 많아지거나 많은 수의 필드를 가진 객체에 바인딩해야 한다면 이런 작업이 의미가 달라지는데, NEW 명령을 통해 귀찮은 작업을 수행하도록 할 수 있다.
  ```java
    //1) 패키지 명을 포함한 전체 클래스 명을 입력해야 하며
    //2) 해당 클래스에 순서와 타입이 일치하는 생성자가 있어야 한다.
    TypedQuery<UserDTO> query = 
        em.createQuery("SELECT new com.example.dto.UserDTO(m.username, m.age) FROM Member m"
        , UserDTO.class);
  ```

  - 페이징 API
    - JPA에서는 DBMS별로 문법도 매우 다르며 까다로운 페이징 처리 API를 지원한다.
    - 단, 페이징 SQL을 최적화하기 위해선 네이티브 SQL을 직접 작성해야한다.
      ```java
      TypedQuery<Member> query=em.createQuery("SQL...", Member.class);

      //조회 시작 위치
      query.setFirstResult(10);
      //한 번 조회당 데이터 수
      query.setMaxResults(20);  //메서드 두개면 된다.
      ```

  <br>
   - JPQL에서의 조인 (+ 경로표현식)

 - UPDATE문
 - DELETE문



 

 - 다형성 쿼리
 - 사용자 정의 함수 호출
 - 엔티티 직접 사용 ( 기본 키값, 외래 키값)
 - Named Query(정적 쿼리)












<br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br>

```
SELECT문 ::=
    SELECT
    FROM
    [WHERE]
    [GROUPBY]
    [HAVING]
    [ORDERBY]

<!-- 벌크 연산 -->
UPDATE문 ::= UPDATE [WHERE]
DELETE문 ::= DELETE [WHERE]
```

1. Criteria
 - JPQL을 편하게 작성하도록 도와주는 API. 빌더 클래스의 모음
 - 문자가 아니라 프로그래밍 코드로 JPQL을 작성할 수 있다.
   -  런타임 시점에 오류를 체크할 수 있다.
   -  IDE에서 코드 자동 완성 기능을 지원한다
   -  Dynamic Query작성이 편하다.


```java
//Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

//루트 클래스
Root<Member> m = query.from(Member.class);

//쿼리 생성
CriteriaQuery<Member> cq =
 query.select(m).where(cb.equal(m.get("username"), "kim"));
//Java의 Annotation Processor 기능을 통한 메타 모델 사용시
CriteriaQuery<Member> cq = 
 query.select(m).where(cb.equal(m.get(Member_.username), "kim"));

List<Member> resuiltList = em.createQUery(cq).getResultList();

```

1. QueryDSL
 - Criteria처럼 JPQL을 편하게 작성하도록 도와주는 빌더클래스 모음. 비표준 오픈소스 프레임워크.
 - 장황하고 복잡한 Criteria에 비해 단순하고 사용하기 쉽다.

```java
//준비
JPAQuery query = new JPAQuery(em);
    //QMember는 어노테이션 프로세서를 사용하여 Member 엔티티 클래스를 기반으로 생성한 쿼리 전용 클래스.
QMember member = QMember.member;

//쿼리, 결과조회
List<Member> members = 
            query.from(member)
            .where(member.username.eq("kim"))
            .list(member);
```




5. native SQL
 - JPA에서 JPQL대신 SQL을 직접 사용할 수 있다.
 - 오라클의 CONNECT BY등 표준화되어있지 않은 기능들을 사용하기 위한 기능.


```java
String sql = "SELECT id, age, team_id, name FROM member WHERE name = 'kim'";
List<Member> resultList = em.createNativeQuery(sql, Member.class).getResultList();
```

6. JDBC 직접 사용. MyBatis와 같은 SQL Mapper Framework 사용
 - JPA는 JDBC 커넥션을 위한 API 제공하지 않으므로, JPA 구현체가 제공하는 방법 사용. 
```java
//Hibernate
Session session = em.unwrap(Session.class);
session.doWork(new Work(){
    @Override
    public void execute(Connection conn) throws Exception{
        //work
    }
})
```
 - JDBC나 MyBatis는 JPA가 인식하지 못하고 JPA를 우회하여 DataBase에 접근하기 때문에 영속성 컨텍스트를 적절한 시점에(SQL 실행 직전에) 강제로 플러시하여 데이터베이스와 영속성 컨텍스트를 동기화 한다.
   - 스프링 AOP를 적절히 활용해 JPA를 우회하여 DB에 접근하는 메서드 호출시마다 영속성 컨텍스트를 플러시하도록 하는 방법이 있다.

1. JPQL advanced
