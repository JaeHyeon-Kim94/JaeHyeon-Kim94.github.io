---
title : JPA(12)-값 타입
categories : [jpa]
tags: [jpa, hibernate]
published : false
---


값 타입

 - 1) 기본값 타입
   - java primitive type( ex. int, double ..)
   - wrapper class ( Integer, Long )
   - String


 - 2) 임베디드 타입(JPA에서 사용자가 직접 정의하는 값 타입. 복합 값 타입)

```java
@Entity
public class Member{
    @Id @GeneratedValue
    private Long id;

    private String city;
    private String street;
    private String zipcode;
    
    @Temporal(TemporalType.DATE)
    private Date startDate;

    @Temporal(TemporalType.DATE)
    private Date endDate;
}
```
여기서 데이터 타입을 정의하여 묶으면

```java
@Entity
public class Member{
    @Id @GeneratedValue
    private Long id;

    @Embedded Period workPeriod;
    @Embedded Address address;
}

@Embeddable
public class Period{
    @Temporal(TemporalType.DATE)
    private Date startDate;

    @Temporal(TemporalType.DATE)
    private Date endDate;
}

@Embeddable
public class Address{
    private String city;
    private String street;
    private String zipcode;
}
```

 - @Embedded : 값 타입을 사용하는 곳에 사용
 - @Embddable : 값 타입을 정의하는 곳에 사용
 - 둘 중 하나는 생략 가능하다.
 - 임베디드 타입은 기본 생성자가 필수
 - Member와 Period, Address를 UML로 표현하면 컴포지션 관계.
   - 컴포지션 : 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함하여 메서드를 호출하는 기법.

```java
@Entity
public class Meber{
    @Embedded Address address;      //임베디드 타입 포함
    @Embedded PhoneNumber phoneNumber;//임베디드 타입 포함
}

@Embeddable
public class Address{
    String street;
    String city;
    String state;
    @Embedded Zipcode zipcode;//임베디드 타입 포함
}

@Embeddable
public class Zipcode{
    String zip;
    String plusFour;
}

@Embeddable
public class PhoneNumber{
    String areaCode;
    String localNumber;
    @ManyToOne PhoneServiceProvider provider; //엔티티 참조
}

@Entity
public class PhoneServiceProvider{
    @Id
    String name;
}
```
 - 엔티티는 공유될 수 있기 때문에 참조한다고 표현하고, 값 타입은 특정 주인에 소속되며 논리적인 개념상 공유되지 않으므로 포함한다고 표현한다.
   - Address가 값 타입인 Zipcode를 포함하고, PhoneNumber가 엔티티 타입인 PhoneServiceProvider를 참조한다.


 - @AttributeOverride
   - 매핑정보 재정의

```java
public class Member{
    @Id @GeneratedValue
    private Long id;
    
    @Embedded Address homeAddress;
    @Embedded Address companyAddress;   //컬럼이 중복될 것이다.
}
//@AttributeOverride 사용

public class Memer{
    @Id @GeneratedValue
    private Long id;
    
    @Embedded Address homeAddress;    

    @Embedded
    @AttributeOverrides({
        @AttributeOverride( name = "city", column = @Column( name = "company_city" )),
        @AttributeOverride( name = "street", column = @Column( name = "company_street" )),
        @AttributeOverride( name = "zipcode", column = @Column( name = "company_zipcode" ))
    })
    Address companyAddress
}
```

```sql
CREATE TABLE member(
    company_city VARCHAR(255)
    , company_street VARCHAR(255)
    , company_zipcode VARCHAR(255)
    , city VARCHAR(255)
    , street VARCHAR(255)
    , zipcode VARCHAR(255)
)
```

 - 임베디드타입의 값을 null로 주면 매핑된 컬럼의 값은 모두 null이 된다.
 - @AttributeOverrides는 엔티티에 설정해야 한다.



 - 값 타입을 공유해선 안된다. 컨텍스트에 의해 하나의 인스턴스를 같이 참조하게 되므로 primitive타입과 달리 같은 참조변수에 대해 값을 변경하거나 하면 dirty checking에 의해 다른 엔티티에 대해 update sql이 날아간다. 따라서 인스턴스를 clone해서 사용해야 한다.
애초에 이런 부작용을 막으려면 setter 메서드를 제거하도록 한다.
따라서 객체를 불변객체로서 설계하도록 한다. 즉, 생성자로 초기값을 설정한 뒤 setter를 없애고 getter만 노출시킨다.


 - 값 타입 컬렉션
   - 값 타입을 하나 이상 저장하려면 컬렉션을 사용한 뒤 @ElementCollection, @CollectionTable 어노테이션을 사용한다.

 - 값 타입은 불변하여 수정이 불가하기 때문에 변경하려면 삭제하고 다시 등록해야 한다. 따라서 비교가 동반되므로 equals와 hashcode를 반드시 구현해야 한다.

 - 특정 엔티티 하나에 속한 값 타입은 변경되어도 자신이 속한 엔티티를 찾아 값을 변경하면 되지만, 값 타입 컬렉션에 보관된 값 타입들은 별도의 테이블에 보관되기 때문에, 값 타입의 값이 변경되면 원본 데이터를 찾기 어렵다. 따라서 JPA 구현체들은 값 타입 컬렉션에 변경 사항이 발생하면 해당 타입 컬렉션이 매핑된 테이블의 모든 연관된 데이터를 삭제하고 다시 모든 값을 저장한다. 따라서 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 값 타입 컬렉션 대신 일대다 관계를 고려해야 한다.
   - 값 타입 컬렉션을 사용하는 대신 새로운 엔티티를 만들어 일대다 관계로 설정하고 영속성 전이(cascade)와 고아 객체 제거(orphan remove) 기능을 추가하면 값 타입 컬렉션처럼 사용할 수 있다.



 - 값 타입과 엔티티의 구별
   - 식별자가 필요하고 지속적으로 값을 추적하고 구분하고 변경해야 한다면 값이 아닌 엔티티이다.


 - 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야 한다.


```java
@Entity
public class Member{
    @Id @GeneratedValue
    private Long id;

    @Embedded
    private Address homeAddress;

    @ElementCollection
    @CollectionTable( name = "favorite_foods"
    , joinColumns = @JoinColumn ( name = "member_id" ) )
    @Column( name = "food_name" )   //사용되는 컬럼이 하나일 경우 지정
    private Set<String> favoriteFoods = new HashSet();

    @ElementCollection
    @CollectionTable( name = "address"
    , joinColumns = @JoinColumn ( name = "member_id" ))
    private List<Addrss> addressHistory = new ArrayList();
}

@Embeddable
public class Addrss{
    @Column
    private String city;
    private String street;
    private String zipcode;
}

```
 - 값 타입 컬렉션은 cascade + orphan remove 기능을 필수로 가진다.
 - 페치 전략은 lazy가 기본값이다.


 - 3) 컬렉션 값 타입



