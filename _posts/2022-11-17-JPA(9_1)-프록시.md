---
title : JPA(9_1) - 프록시
categories : [jpa]
tags: [jpa, hibernate]
published : false
---

 - 즉시 로딩 : 엔티티 조회시 연관된 엔티티도 함께 조회
   - @ManyToOne( fetch = FetchType.EAGER )
   - 즉시 로딩 최적화를 위해 JPA는 조인 쿼리 사용.
     - 외래 키가 **NULLABLE일 경우 JPA는 값이 없을 경우를 대비해서 OUTER JOIN을 수행**한다. 성능상 INNER JOIN이 유리하므로 NOT NULL 제약조건 설정시 INNER JOIN 수행함. JPA가 이런 사실을 알게 하려면 **@JoinColumn에 nullable = false **속성을 주거나 **@ManyToOne에 optional = false**를 주면 됨.


 - 지연 로딩 : 엔티티 조회시 연관된 엔티티는 실제 사용할 때 조회.
   - @ManyToOne( fetch = FetchType.LAZY )
   - 즉, Member(@ManyToOne)과 Team(@OneToMany)가 있을 때, em.find(Member)시 **Member만 조회하고 Team 멤버변수에는 프록시 객체를 넣어둔다**. 그리고 프록시 객체는 실제 사용될 때까지 로딩을 미룬다. 단, 조회 대상이 컨텍스트에서 관리되고 있다면 프록시가 아니라 실제 객체를 사용한다.



 - 무엇을 사용해야 하는가?
   - 예를 들어 멤버 엔티티와 팀 엔티티를 주로 함께 사용한다면 즉시 로딩이, 그렇지 않다면 지연 로딩이 유리할 수 있다.



 - 컬렉션 래퍼
   - 하이버네이트에선 엔티티를 영속화할 때 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 하이버네이트 내장 컬렉션으로 변경하는데, 이 내장 컬렉션을 컬렉션 래퍼라고 한다. 엔티티의 지연로딩은 프록시 객체가 처리해주는 것처럼, 컬렉션은 컬렉션 레퍼가 프록시처럼 지연 로딩을 처리해준다. memgers.getOrder()로는 초기화되지 않고, getOreders().get(0)처럼 실제 데이터를 조회할 때 데이터베이스를 조회하여 초기화한다. getOrder().get(0)시 즉시로딩 설정한 상품 또한 같이 로딩된다.


 - JPA 기본 페치 전략
   - @MayToOne, @OneToOne : EAGER
   - @OneToMany, @ManyToMany : Lazy
     - 일대 다 조인을 하면 당연히 성능 저하로 이어질 수 있다.


 - JPA는 일대다 관계를 즉시로딩할 때 항상 외부 조인을 사용하기 때문에, 컬렉션 즉시 로딩도 항상 외부 조인을 사용한다.
   - @ManyToOne, @OneToOne
     - optional = false : 내부조인
     - optional = true : 외부조인

   - @OneToMany, @ManyToMany
     - optional = false : 외부 조인
     - optional = true : 외부 조인


