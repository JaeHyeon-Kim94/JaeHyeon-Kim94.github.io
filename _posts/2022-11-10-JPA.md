---
title : JPA
categories : [jpa]
tags: [jpa, hibernate]
published: true
---

>본 포스팅은 김영한님의 자바 ORM 표준 JPA 프로그래밍의 일부 내용을 요약한 글임.
>>[자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/Product/Goods/19040233)




# **1 장.**　JPA 소개

 - 자바 ORM 기술에 관한 API 표준 명세로서, 인터페이스에 해당함.
 - 이러한 표준 명세를 구현한 구현체, 즉 ORM 프레임워크는 여러 종류가 있는데 Hibernate가 많이 쓰인다.
   - 따라서 사용하는 객체가 javax.persistence로 시작한다면 JPA 표준 속성이기 때문에 ORM 프레임워크에 종속적이지 않지만, hibernate로 시작한다면 hibernate 구현체이기 때문에 hibernate에서만 사용할 수 있다. 


<br>
<hr>
<br>

# **2 장.**　JPA 시작

## 2.3 라이브러리와 프로젝트 구조

   - hibernate의 핵심 라이브러리
     - hibernate-core
     - hibernate-entitymanager : 하이버네이트가 JPA 구현체로서 동작하도록 구현한 라이브러리.
     - hibernate-jpa-2.1-api : JPA 2.1 표준 API를 모아둔 라이브러리

## 2.4  기본적 매핑 어노테이션

  - @Entity : 이 클래스(엔티티 클래스)를 테이블과 매핑하겠다.
  - @Table(name="tableName") : 엔티티 클래스에 매핑할 테이블 정보를 명시한다. 생략시 클래스명.
  - @Id : primary key
  - @Column(name="columnName") : 필드를 컬럼에 매핑한다. 지정하지 않을 시 필드 명의 컬럼과 매핑되는데, DB에서 대소문자를 구별하는 경우에는 그에 맞게 대소문자를 맞춰준다.

## 2.5 persistence 설정

  - persistence-unit : 연결할 DB당 하나의 영속성 유닛을 등록하며, 고유한 이름을 부여해야 한다.
  - 그 외에 필수 속성으로 jdbc driver, jdbc user, jdbc password, jdbc url, hibernate.dialect 설정이 필요하다.
  - Optional properties
    - hibernate.show_sql : 하이버네이트가 실행한 SQL 출력
    - hibernate.format_sql : 하이버네이트가 실행한 SQL을 출력할 때 보기 쉽게 정렬.
    - hibernate.use_sql_comments : 주석도 함께 출력.
    - hibernate.id.new_generator_mappings : JPA 표준에 맞춘 새로운 키 생성 전략 사용. TODO


## 2.6 애플리케이션 개발

  - 엔티티 매니저 설정
    - EntityManagerFactory emf = Persistence.createEntityManagerFactory("영속성 유닛 이름");
      - emf는 생성 비용이 매우 크기 때문에 애플리케이션 전역에서 한 번만 생성하고 공유해서 사용.      - EntityManager em = emf.createEntityManager();
      - em을 이용해 CRUD. 내부에 데이터소스 유지하며 DB와 통신
      - DB Connection과 밀접한 관계이므로 스레드간 공유시 동시성 문제 발생. 스레드간 공유 절대 금지.
    - em.close(), emf.close()

     ![entity_manager_init_process.PNG](../../assets/img/entity_manager_init_process.PNG)
  
  - 트랜잭션 관리
      - JPA에서는 항상 트랜잭션 안에서 데이터 변경해야 하며 그렇지 않을 경우 예외 발생.
      - EntityTransaction tx = em.getTransaction();
      - tx.begin() //트랜잭션 시작
      
      - tx.commit(); //트랜잭션 커밋
      - tx.rollback(); //트랜잭션 롤백
      
  - 비즈니스 로직
      - logic(em) //비즈니스 로직 실행


### 　2.6.4 JPQL

  - SQL을 추상화 한 객체지향 쿼리 언어.
  - SQL과 문법이 거의 유사
  - 다만 차이점은 엔티티 객체를 대상으로 쿼리. SQL은 DB Table 대상.
    - JPQL은 테이블 전혀 알지 못함.
  - em.createQuery(JPQL, 반환 타입).getResultList();

<br>
<hr>
<br>

# **3 장.**　영속성 관리


##    3.1 엔티티 매니저 팩토리 & 엔티티 매니저

  - ![](../../assets/img/web_application.png)
    - EntityManager1은 connection을 얻지 않았는데, 데이터베이스 연결이 필요한 시점까지 커넥션 얻지 않기 때문.
    - EntityManagerFactory 생성시 커넥션 풀도 만듬. 다만 스프링 framework를 비롯한 J2EE 환경에선 해당 컨테이너가 제공하는 데이터 소스 사용함.


##    3.2 영속성 컨텍스트(Persistence Context)

  - 엔티티를 영구 저장하는 환경
  - 엔티티 매니저 생성시 하나 만들어짐. 엔티티 매니저를 통해 접근 및 관리 가능.


##    3.3 Entity LifeCycle

   - 엔티티의 상태 4가지
     - 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
       - 저장하지 않은 순수한 객체 상태. 
     - 영속(managed) ; 영속성 컨텍스트에 저장된 상태
       - 영속성 컨텍스트에 의해 관리되는 상태. ex) em.persist() 후
     - 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
       - em.detach() 혹은 em.close()를 통해 영속성 컨텍스트를 닫거나, em.clear()로 영속성 컨텍스트 초기화.
     - 삭제(removed) : 삭제된 상태
       - em.remove(객체)
   - ![](../../assets/img/entity_life_cycle.png)

##    3.4 영속성 컨텍스트의 특징

   장점1) 1차 캐시
   3.4.1 엔티티 조회
   - 영속성 컨텍스트는 엔티티를 @Id(식별자 값)으로 구분하기 때문에 영속 상태는 식별자 값이 반드시 존재해야 하며 없으면 예외 발생함.
   - 영속성 컨텍스트에 저장한 엔티티는 flush를 통해 데이터베이스에 반영된다.
   - 영속성 컨텍스트의 1차 캐시
     - @Id의 값을 key, 인스턴스 값을 value로 하는 Map 구조. em.find시 db에 접근하기 전에 이 1차 캐시에서 찾고 없으면 DB에서 조회.
       - DB에서 조회할 경우 엔티티를 생성하여 그 결과를 1차 캐시에 저장한 후 영속 상태의 엔티티 반환함
       - 메모리에 접근하는 것이기 때문에 성능상 이점이 있다.
       - 캐시에서 반환되는 것이기 때문에 여러번 호출해도 같은 인스턴스를 반환한다. 즉, 엔티티의 동일성.
         - cf) 동일성(identity): 인스턴스가 같음 / 동등성(equality) : 인스턴스는 다를 수 있지만 값이 같음. equals시 true

###     3.4.2 엔티티 등록

   - persist()시 key(@Id)-value(instance)를 1차 캐시에 저장하며, <br>
INSERT SQL을 지연 SQL 저장소에 차곡차곡 모아둠(transcational write-behind).

   - commit()시 flush 후 commit한다.
    
###     3.4.3 엔티티 수정

   - JPA는 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장(스냅샷)해두고, flush( trasncation.commit() )하는 시점에 엔티티와 스냅샷을 비교해 변경된 엔티티를 찾는다(변경 감지; dirty checking)
   - 변경된 엔티티가 있다면 수정 쿼리를 그때 생성하여 쓰기 지연 SQL 저장소에 보내고 DB에 반영한 후 DB 트랜잭션 커밋.
   - 변경 감지를 위해선 엔티티가 영속 상태(영속성 컨텍스트가 관리하는 상태)여야 한다.
   - 엔티티의 일부 필드만 변경하더라도 JPA는 모든 필드를 업데이트 한다.
     - 이러한 방식은 일부를 바꾸든 전부를 바꾸든 동일한 SQL을 사용하므로 애플리케이션 로딩시점에 수정 쿼리를 미리 만들어 재사용할 수 있는 장점이 있지만, 데이터 전송량 증가라는 단점도 있다.
     - @Org.hibernate.annotations.DynamicUpdate를 통해 일부만 업데이트 하는 쿼리를 생성하도록 할 순 있다.
     - @DynamicInsert는 insert sql을 동적으로 생성.


###      3.4.4 엔티티 삭제

  - 등록 수정과 마찬가지로 em.remove()시 바로 삭제하는 것이 아니라 삭제 쿼리를 지연 SQL 저장소에 저장하고, 트랜잭션 커밋시 플러쉬 되면서 DB 커밋이 된다. em.remove시 엔티티는 removed 삭제로서 영속성 컨텍스트에서 제외된다.
       

##      3.5 플러시

  - 영속성 컨텍스트의 변경 내용을 DB에 반영.
    - 플러시 한다고 영속성 컨텍스트에 보관된 엔티티가 지워지는 건 아니다. DB와 동기화 되는 개념.
    - 지연된 쿼리가 가능한 건 작업 단위인 트랜잭션의 특징 때문.(변경 내용은 커밋 직전에만 동기화 하면 됨.)
  - 작업 1) 영속성 컨텍스트의 모든 엔티티에 대해 스냅샷 비교(변경 감지)를 통해 수정 쿼리 작성 및 지연 SQL 저장소 등록
  - 작업 2) 지연 SQL 저장소에 쌓인 쿼리를 DB에 전송(insert, update, delete)
      
  - 플러시 방법
    - em.flush() 직접 호출
      - 테스트시 사용
    - 트랜잭션 커밋시 플러시 자동 호출
    - JPQL 쿼리 실행시 플러시 자동 호출
      - ex) 
         ```java
          em.persist(member1);
          em.persist(member2);
          //JPQL 실행 시점에 플러시 자동 호출. member1, member2도 쿼리의 결과에 포함된다.
          //식별자를 기준으로 조회하는 find() 메서드 호출시에는 플러시X
          em.createQuery("select m from Member m", Member.class).getResultList();
         ```
        
###      3.5.1 플러시 모드 옵션

  - javax.persistence.FlushModeType 이용
  - FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때.(default)
  - FlushModeType.COMMIT : 커밋할 때만
    - 성능 최적화를 위해 사용할 수도 있음.


##      3.6 준영속

   - 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 컨텍스트에서 분리된 것. 분리되었기 때문에 컨텍스트가 제공하는 기능은 당연히 사용할 수 없다. (변경 감지 X...)
   - how?
     - em.detache(entity) : 특정 엔티티만 준영속 상태로 전환
       - 엔티티를 관리하기 위한 모든 정보가 제거됨. 
       - detache(memberA) -> memberA의 1차 캐시 제거 + 관련 SQL 제거
     - em.clear() : 영속성 컨텍스트 초기화
       - 해당 컨텍스트의 모든 엔티티를 준영속 상태로 만듬.
       - 1차 캐시나 쓰기 지연 SQL 저장소는 남음.
     - em.close() : 영속성 컨텍스트 종료
       - em.clear에서 1차 캐시, 쓰기 지연 SQL 저장소까지 삭제


  - 비영속과 차이점?
    - 컨텍스트 제공 기능 사용 불가 등 거의 유사하나, 영속 상태였었으므로 반드시 식별자는 가짐.
    - 지연 로딩 X. (지연 로딩은 실제 객체 대신 프록시 객체를 로딩하고 실제로 사용할 때 영속성 컨텍스트를 통해 데이터 불러오는 방법.)


  - 다시 영속 상태로 하려면?
    - 병합; merge() 사용
      - ex) Member mergeMember = em.merge(member);
  - 준영속 -> 영속<br>
     ![](../../assets/img/merge_process.png)
    - 프로세스 설명
      - (1) merge() 실행
      - (2) merge(member)의 파라미터인 준영속상태 엔티티의 식별자 값으로 1차 캐시에서 엔티티 찾음.
      - (2-1) 1차 캐시에 없다면 DB에서 조회하고 캐시에 저장
      - (3) 조회한 영속 엔티티(mergeMember)에 member 엔티티의 모든 값을 밀어넣는다. member 엔티티는 merge 하더라도 계속 준영속 상태임. 새로운 Member 인스턴스인 mergeMember를 리턴하는 것.
      - (4) 영속 엔티티(mergeMember) 반환한다.

  - 비영속 -> 영속
    - merge는 준영속, 비영속을 가리지 않고 동작하는데, 파라미터로 넘어온 엔티티의 식별자 값으로 1차 캐시에서 조회하고 없으면 DB, DB에도 없으면 새로운 엔티티를 생성해서 병합한다.(save or update 기능)

<br>
<hr>
<br>

# **4 장.**　엔티티 매핑

 - 매핑 어노테이션의 4가지 분류
   - 1) 객체(@Entity) - 테이블(@Table)
   - 2) 기본 키(@Id)
   - 3) 필드 - 컬럼(@Column)
   - 4) 연관 관계(@ManyToOne, @JoinColumn)

## 4.1 @Entity

 - 속성
   - name : JPA에서 사용할 엔티티의 이름. 기본 값은 클래스명. 다른 패키지의 동일한 이름의 클래스의 경우 충돌하지 않도록 이름 지정할 것.

 - 기본 생성자 필수.(인자가 없는)(접근 제어자는 public 혹은 protected)
 - final class, enum, interface, inner class 불가.
 - 필드에 final X



## 4.2 @Table

 - 속성
   - name : 매핑할 테이블 명
   - catalog : DB가 catalog 기능 있는 경우 catalog 매핑
   - schema : DB가 schema 기능 있는 경우 schema 매핑
     - DDL 생성시 유니크 제약조건...? TODO


## 4.3 다양한 매핑 사용

- @Enumerated (자바의 enum 사용시 이 어노테이션으로 매핑.)
  - 속성
    - EnumType.ORDINAL : enum **순서**를 DB에 저장.
      - ex)1, 2, 3....
    - EnumType.STRING : enum **이름**을 DB에 저장.
      - ex)USER, ADMIN
    - 기본 값은 ORDINAL

- @Temporal
  - 자바의 날짜 타입은 이 어노테이션 사용해 매핑.

- @Lob
  - CLOB, BLOB 타입 매핑.



## 4.4 데이터베이스 스키마 자동 생성

- JPA는 매핑 정보와 DB Dialect를 활용해 데이터베이스 스키마 생성함.
  - hibernate.hbm2ddl.auto 속성 설정 필요. 다음은 속성 값
    - create : DROP + CREATE
    - create-drop : DROP + CREATE + DROP (create 속성에 애플리케이션 종료시 생성한 DDL 제거.)
    - update : 데이터베이스 테이블과 엔티티 매핑 정보 비교하여 변경 사항만 수정.
    - validate : 데이터베이스 테이블과 엔티티 매핑 정보 비교하여 변경 사항 있으면 경고와 함께 애플리케이션 실행 X. DDL 건드리지 않음.
    - none : 자동 생성 기능 사용X.(이 값은 유효하지 않은 값으로, 속성 자체를 설정 파일에서 지우거나 유효하지 않은 값을 넣으면 기능 사용 X.)
- 다만, 운영 환경에서 사용할 정도로 완성도가 높지 않을 수 있음.
 hibernate.ejb.naming_strategy = org.hibernate.cfg.ImprovedNamingStrategy
  - 자바는 카멜 케이스, 데이터베이스는 언더스코어 표기법 사용하기 때문에 그 차이를 해결해주는 설정.
  - 설정에 위 속성을 추가하면 테이블 혹은 컬럼 명 생략시 언더스코어 표기법으로 DDL 구성.



## 4.5 DDL 생성 기능

1) &nbsp;@Column
```java
  @Column(name="user_name", nullable = false, length = 10)
  private String userName;
```


2) &nbsp;@TABLE
```java
  @Entity(name="MEMBER")
  @Table(name="MEMBER", uniqueConstraints = {@UniqueConstraint(name = "name_age_unique",
                                                               columnNames = {"name", "age"} )})
  public class Member{
    ...
  }
```
 - 이런건 그냥 DDL 작성해도 되지만, 이 기능을 사용함으로써 엔티티만 보고도 테이블 스키마 파악 가능하니 사용하는 것이 좋을 것 같다.


## 4.6 기본 키 매핑

 - JPA가 제공하는 데이터베이스 기본 키 생성 전략
   - 직접 할당 : 기본 키를 애플리케이션에서 직접 할당
   - 자동 생성 : 대리 키 사용 방식(후보키 중 기본 키 아닌 것.)
     - IDENTITY : 기본 키 생성을 DB에 위임.
     - SEQUENCE : DB 시퀀스 사용해 기본 키 할당
     - TABLE : 키 생성 테이블 사용
     - hibernate.id.new_generator_mappings = true 설정 필요.



### 4.6.1 기본 키 직접 할당 전략

 - @Id
   - 적용 가능한 자바 타입
     - primitive
     - Wrapper class
     - String
     - java.util.Date
     - java.sql.Date
     - java.math.BigDecimal
     - java.math.BigInteger



### 4.6.2 IDENTITY 전략

 - 기본 키 생성을 DB에 위임.
 - MySQL, PostgreSQL, SQL Sever, DB2
 - 용례

```java
  ...
  @Id
  @GeneratedValue( strategy = GenerationType.IDENTITY )
  private Long id;
  ...
```
 - MySQL의 경우 id 컬럼에 auto_increment 적용 되어있어야 한다.
 - 이 전략을 사용하면 JPA는 기본 키 값을 얻어오기 위해 DB를 추가로 조회한다. DB에 INSERT 한 후에 기본 키 값을 조회할 수 있기 때문.
   - hibernate는 JDBC3의 Statement.getGereatedKeys()를 이용하여 저장과 동시에 기본 키 값 얻어옴(?)TODO
 - 엔티티가 영속상태이려면 식별자가 반드시 필요하기 때문에, INSERT가 되어야 식별자를 구할 수 있는 IDENTITY 전략의 경우 SQL 쓰기 지연이 동작하지 않는다. 즉, em.persist()시 곧바로 SQL 날아간다.


### 4.6.3 SEQUENCE 전략

 - DB에서 시퀀스는 유일한 값을 순서대로 생성하는 DB Object.
 - - Oracle, PostgreSQL, DB2, H2에서 주로 사용
 - SEQUENCE 전략은 이 시퀀스 이용해 기본 키 생성.
   - 시퀀스 생성 해주어야 하며, 
     - ex) CREATE SEQUENCE board_seq START WITH 1 INCREMENT BY 1;

```java
  @Entity
  public class Board{
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE,
                    generator = "board_seq_generator")
    @SequenceGenerator(
      name = "board_seq_generator",
      sequenceName = "board_seq",
      initialValue = 1, 
      allocationSize = 1
    )
    private Long id;
  }
```
 - @SequenceGenerator를 통해 board_seq_generator 시퀀스 생성기 등록
 - sequenceName인 board_seq는 JPA가 매핑할 데이터베이스의 시퀀스 이름.
 - generator는 방금 생성한 시퀀스 생성기를 지칭함.
 - IDENTITY 전략의 경우 DB에 저장한 후 식별자를 받아오는 방식이었다면, SEQUENCE 전략은 먼저 DB 시퀀스를 사용해 식별자를 조회하고, 조회한 식별자를 엔티티에 할당한 다음 영속성 컨텍스트에 엔티티를 저장한다. 이 후 트랜잭션을 커밋하여 플러시가 일어나면 엔티티가 DB에 저장되는 방식이다.
 - @SequenceGenerator
   - 속성
     - name : 식별자 생성기 이름. (필수)
     - sequenceName : 데이터베이스에 등록되어있는 시퀀스의 이름. (기본값 : hibernate_sequence)
     - initialValue : 시퀀스 DDL 생성시 처음 시작하는 수 지정. DDL 생성시에만 사용됨. (기본값 : 1)
     - allocationSize : 시퀀스 한 번 호출에 증가하는 수(기본값 : 50)
       - 기본값이 50인 이유 : 50씩 증가하면 여러 JVM이 동작하더라도 기본 키 값이 충돌하지 않게 하려고 + 시퀀스 접근 횟수 줄이기 위해(메모리에서 식별자 할당).
     - catalog.schema : 데이터베이스 catalog, schema 이름.



### 4.6.4 TABLE 전략

 - 키 생성 전용 테이블을 만들어 이를 활용하는 방식.

```sql
  CREATE table my_sequences (
    sequence_name VARCHAR(255) NOT NULL,
    next_val BIGINT,
    PRIMARY KEY ( sequence_ name )
  )
```

<br>

```java
  @Entity
  @TableGenerator(
    name = "board_seq_generator",
    table = "my_sequences",
    pkColumnValue = "board_seq",
    allocationSize = 1
  )
  public class Board{
    @Id
    @GeneratedValue( strategy = GenerationType.TABLE,
          generator = "board_seq_generator")
    private Long id;
  }
```
  - @TableGenerator
    - 속성
      - name : 식별자 생성기 이름. @GeneratedValue와 매핑시 사용 (필수)
      - table : DB에 생성한 식별자 테이블 명(기본값 : hibernate_sequences )
      - pkColumnName : 시퀀스 컬럼 명 (기본값 : sequence_name )
      - valueColumnName : 시퀀스 값 컬럼명( 기본값 : next_val )
      - pkColumnValue : 키로 사용할 값 이름 (기본값 : 엔티티 이름)
      - initialValue : 초기 값. (기본값 : 0)
      - allocationSize : 시퀀스 한 번 호출에 증가하는 수 (기본값 : 50)
      - catalog, schema : 데이터베이스 catalog, schema 이름
      - uniqueConstraints(DDL) : 유니크 제약 조건 지정.

### 4.6.5 AUTO 전략

 - 설정에 기술한 Dialect를 기준으로 자동으로 선택하는 전략.(IDENTITY, SEQUENCE, TABLE)
 - Oracle의 경우 SEQUENCE를, MySQL의 경우 IDENTITY를 선택한다.

```java
  @GeneratedValue( strategy = GenerationType.AUTO )
```
<br>
<br>


> 식별자 선택 전략
> > 기본 키는 유일성, 불변성, Not Null 세 가지 조건을 모두 만족해야 함.
> > 기본 키를 선택하는 전략은 자연 키(주민번호 등 비즈니스에 의미가 있는 키), 대리 키(시퀀스 등 비즈니스와 관계 없이 임의로 만들어진 키, 대체 키)가 있는데, 대리 키가 권장됨. 주민번호와 같이 비즈니스의 영향을 받는 경우 불변성을 완전히 만족한다고 보장할 수 없음.


<br>


## 4.7 필드와 컬럼 매핑 : 레퍼런스

  - @Column : 컬럼 매핑

| 속성  | 기능  | 기본값  |
| --- | --- | --- |
| `name`  | 필드와 매핑할 테이블 컬럼 이름  | 객체의 필드 이름  |
| `insertable`  | SQL INSERT문에 해당 필드를 포함할 것인지 여부 | true  |
| `updatable` | SQL UPDATE문에 해당 필드를 포함할 것인지 여부 | true  |
| `table` | 한 엔티티를 두 개 이상의 테이블에 매핑할 떄 사용  | 현재 매핑된 테이블  |
| `nullable`(DDL) | null값의 허용 여부 설정 | true  |
| `unique`(DDL)| @Table의 uniqueConstraints와 같음.<br>두 컬럼 이상을 조건을 걸어주려면 <br>uniqueConstraints 사용 | false |
| `columnDefinition`(DDL) | 데이터베이스 컬럼 정보를 직접 줄 수 있음. | 필드의 자바 타입과<br> dialect 이용해<br> 적절한 컬럼 타입 생성 | 
| `length`(DDL) | 문자 길이 제약 조건 String 타입. | 255 |
| `precision`, `scale`(DDL) | BigDecimal, BigInteger 타입에서 사용. <br>precision은 소수점 포함 전체 자릿수, <br> scale은 소수의 자릿수. <br> double, float 타입은 적용 X. | precision = 19, <br> scale = 2 |

   - @Column 생략시 속성들은 대부분 기본값으로 설정되는데, int와 같은 primitive 타입은 null이 없기 때문에 not null로 설정된다. 


### 4.7.2 @Enumerated

 - 자바 enum 매핑

 
 속성  | 기능  | 기본값  
 --- | ---|  --- 
`value` | - EnumType.ORDINAL : enum의 순서를 저장 <br> - EnumType.STRING : enum의 이름을 저장 | ORDINAL


### 4.7.3 @Temporal

 - 자바 날짜 타입 매핑(Date, Calendar)

속성|기능|기본값
---|---|---
`value`| - TemporalType.DATE : 날짜, DB의 date 타입과 매핑  <br> - TemporalType.TIME : 시간, DB의 time 타입과 매핑  <br> - TemporalType.TIMESTAMP : 날짜와 시간, DB의 timestamp 타입과 매핑 |   TemporalType은 <br>필수로 지정해야 함.

- @Temporal 생략시 dialect에 따라 MySQL은 datetime, H2, 오라클, PostegreSQL은 timestamp 타입으로 DDL 생성한다.


### 4.7.4 @Lob

 - DB의 BLOB, CLOB 타입과 매핑
 - 속성 없음. 필드 타입이 문자면 CLOB, 나머지는 BLOB


### 4.7.5 @Trnasient

 - 해당 필드는 DB 테이블의 컬럼과 매핑하지 않겠다는 의미.


### 4.7.6 @Access

 - JPA가 엔티티 데이터이 접근하는 방식을 지정.
 - 필드 접근 : AccessType.FIELD
   - private이어도 상관 없이 필드로 접근. 생략시 @Id의 위치를 기준으로 결정하는데, <br>
   필드 위에 있으면 필드 접근, getter 위에 @Id가 있으면 AccessType.PROPERTY로 설정됨.
   - id는 필드 방식을 이용하고 다른 컬럼에는 별도로 AccessType 설정을 통해 접근 방식을 달리할 수 있다.
 - 프로퍼티 접근 : AccessType.PROPERTY
   - Getter 이용.



# **5 장.**　연관관계 매핑 기초

 - 이 장의 목표는 **객체의 참조**와 **테이블의 외래 키**를 매핑하는 것.
 - 관련 키워드
   - 방향(Direction) : 단방향, 양방향이 있으며 한 쪽만이 다른 한쪽을 참조하는 것을 단방향, 서로 참조하는 것을 양방향이라고 함. 테이블의 관계는 항상 양방향임.
   - 다중성(Multiplicity) : 다대일, 일대다, 일대일, 다대다
   - 연관관계의 주인 : 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 함.



## 5.1 단방향 연관관계

 - 테이블의 외래 키를 이용한 연관관계와, 객체 내 참조값을 이용한 연관관계
   - A, B 두 객체가 서로 연관관계가 있을 때 객체 A는 B의 참조값을, B는 A의 참조 값을 갖게 함으로써 양방향 연관관계를 맺게 할 수 있는데, 정확하게 이는 양방향 연관관계가 아니라 서로 다른 단방향 연관관계 2개라고 할 수 있다.
   - 반면 테이블에서 외래 키를 이용한 연관관계는 양방향으로서 A JOIN B 혹은 B JOIN A가 가능하다.



### 5.1.1 순수한 객체 연관관계

 - 객체는 참조값을 사용해 연관관계를 탐색(객체 그래프 탐색)할 수 있다.


### 5.1.2 테이블 연관관계

 - DB에선 테이블의 외래 키를 이용해 연관관계를 탐색(조인)할 수 있다.


### 5.1.3 객체 관계 매핑

![](../../assets/img/relationship_mapping.png)

 - JPA를 통해 객체 연관관계 방식과 테이블 연관관계 방식의 불일치를 해결할 수 있다.

```java
  @Entity
  public class Member{
    @Id
    @Column(name = "MEMBER_ID")
    private String memberId;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;

    ...
  }

  @Entity
  public class Team{
    @Id
    @Column(name = "TEAM_ID")
    private String teamId;

    ...
  }
```

### 5.1.4 @JoinColumn

 - @JoinColumn : 외래 키를 매핑할 때 사용. 생략 가능.
   - 생략하게 되면 외래 키를 찾을 때 기본 전략 사용.
     - 기본 전략 : 필드명+_+참조하는 테이블의 컬럼명
       - team_team_id

속성  | 기능  | 기본값
--- | --- | ---
name  | 외래 키 이름  | 필드명 + "_" 참조하는 테이블의 <br>기본 키 컬럼 명
referencedColumnName  | 외래 키가 참조하는 <br>대상 테이블에서의 컬럼명 | 참조하는 테이블의 <br>기본 키 컬럼명  
foreignKey(DDL) | 외래 키 제약조건을 직접 지정할 수 있음. | 
unique<br>nullable<br>insertable<br>updatable<br>columnDefinition<br>table | @Column의 속성과 같음 | 


 - name과 referencedColumnName의 차이를 설명한 글 : [name vs referencedColumnName](https://stackoverflow.com/questions/53287631/difference-between-name-and-referencedcolumnname-in-joincolumn-annotation)



### 5.1.5 @ManyToOne

 - @ManyToOne : 다대일 관계를 알려주는 매핑 정보

속성  | 기능  | 기본값
--- | --- | ---
optional  | false시 연관된 엔티티가 항상 있어야 한다. <br> true시에는 엔티티가 없는 경우도 조회한다(Outer Join) | true
cascade | 엔티티의 상태 변화를 전파시키는 옵션 | 
targetEntity | 연관된 엔티티의 타입 정보를 설정 | 

 - targetEntity
   - 제네릭으로 타입 정보를 알 수 있기 때문에 사용하지 않아도 됨.
     - ex)

     ```java
      @OneToMany
      private List<Memeber> members

      @OneToMany(targetEntity = Member.class)
      private List Members;
     ```
<br>

## 5.2 연관관계 사용


### 5.2.2 조회

 - 연관관계가 있는 엔티티를 조회하는 방법은 크게 2가지
   - 객체 그래프 탐색(객체 연관관계를 사용한 조회)
     - ex)
     
     ```java
      Member.member = em.find(Member.class, "member1");
      Team team = member.getTeaml();  //객체 그래프 탐색
     ```

   - 객체지향 쿼리(JPQL) 사용.
     - ex)
     
     ```java
      String jpql = "select m from member m join m.team t "
        + "where t.name=:teamname";

      List<Member> resultList = em.createQuery(jpql, Member.class)
      .setParameter("teamName", "팀1")
      .getResultList();
     ```


### 5.2.4 연관관계 제거

```java
  Member member = em.find(Member.class, "member1");
  member.setTeam(null);
```

### 5.2.5 연관된 엔티티 삭제

```java
member.setTeam(null);
em.remove(team);
```
 - 연관관계 제거가 우선적으로 수행되고 나서 연관된 엔티티를 삭제하도록 한다.


## 5.3 양방향 연관관계

 - 테이블 연관관계의 경우 외래 키 하나로 애초에 양방향 연관관계가 관리되지만, 객체 연관관계의 경우 단방향 연관관계만이 존재하기 때문에 단방향 연관관계 두 개로 테이블에서의 양방향 연관관계처럼 구현한다. (이 과정에서 테이블의 양방향 연관관계에서 외래 키 하나를 사용하는 것 처럼 객체 양방향 연관관계에서도 외래 키 필드 하나로 관리되도록 mappedBy 속성을 사용한다. 그렇지 않으면 A의 필드 b(외래키)와 B의 필드 a(외래키) 연관관계를 관리하는 것이 두 개가 되고 이는 테이블 연관관계의 패러다임과 맞지 않다.)
<br>따라서 기존에 존재하던 Member -> Team 연관관계 외에 Team -> Member 연관관계를 설정해주어야 한다.

```java
  @Entity
  public class Team{
    ...
    //여기서 mappedBy = team의 team은 반대쪽 매핑 필드명.
    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<Member>();
  }

  //이제 member.getTeam() 말고 team.getMembers()도 가능하다.
  List<Member> members = team.getMembers();

```


## 5.4 연관관계의 주인
<br>
 - 위에서 기술한 것처럼 객체 양방향 연관관계를 관리하는 외래 키 필드를 테이블 양방향 연관관계처럼 만들기 위해 mappedBy를 사용하는데,<br> 두 객체 연관관계 중 하나를 정해 테이블의 외래 키를 관리하게 하는 것을 연관관계의 주인이라고 한다.<br>
 - 연관관계 주인 쪽에서만 외래 키를 관리(등록, 수정, 삭제)할 수 있고 다른 한 쪽은 읽기만 가능.<br>
 - mappedBy는 주인이 아닌 쪽에서 사용한다.<br>


### 5.4.2 연관관계의 주인은 외래 키가 있는 곳
<br>
 - 연관관계 주인은 테이블에 외래 키가 있는 곳으로 정해야 하기 때문에 Member.team이 주인이 되며, Team.members는 mappedBy=team 속성을 통해 주인이 아님을 명시한다.<br>
 - 다대 일, 일대 다 관계를 살펴보면 항상 다 쪽에서 외래 키를 가지고 있다. 따라서 다 쪽인 ManyToOne은 항상 연관관계의 주인이므로 mappedBy 설정 불가. 이에 따라 속성에 mappedBy가 아예 없음.<br>


## 5.6 양방향 연관관계의 주의점

```java
//1)
  team.getMembers().add(member1); //(X)
//2)
  member1.setTeam(team1); // (O)
```
<br>
 - 연관관계의 주인이 아닌 곳에만 값을 입력해선 안된다.<br> 주인이 아닌 쪽에서 외래 키는 readOnly이므로 member쪽에서 별도로 입력하는게 아닌 이상 값이 입력되지 않는다.<br>
 - 또한 연관관계 주인에만 값을 입력해서도 안된다. 테이블 연관관계의 패러다임 상에서는 주인 쪽에만 값을 입력하면 외래 키를 통해 양방향 연관관계가 관리되지만, 객체 연관관계 패러다임 상에서는 한 쪽에 값을 넣는다고 해서 다른 쪽에서도 이를 이용해 관리되지는 않기 때문이다.<br>

예를 들어

```java

  public class A{
    @ManyToOne
    @JoinColumn(~~)
    private B b;
  }

  public class B{
    @OneToMany(mappedBy="b"
    //, targetEntity = A.class
    )
    private List<A> list = new ArrayList<>();
  }

  main(){
    B b1 = new B();
    A a1 = new A();

    a1.setB(b1);
    
    //1)
    a1.getB();

    //2)
    b.getList()
  }

```

 - 1의 실행 결과는 b1의 값이 나올테지만, 2의 실행 결과는 당연히 빈 arraylist가 나올 것이다. <br>

 - 따라서 결론은 객체 연관관계 패러다임까지 고려하여 양 쪽에 값을 다 넣어주는 것이 양방향 연관관계를 사용하는 과정에서 안전할 것이다.<br>

```java

  public class A{
    private B b;

    public void setB(B b){
      if(this.b != null){
        //연관관계가 바뀔때를 대비한 로직.
        //이 로직이 없으면 B쪽의 a에 대한 연관관계가 list에 남아있게 된다.
        this.b.getList().remove(this);  

        this.b = b;
        this.b.getList().add(this);        
      }
    }
  }
```


# **6 장.**　다양한 연관관계 매핑

 - 다대 일 양방향 관계와 비교되는 일대 다 단방향 관계의 단점
   - 테이블 연관관계 패러다임에선 외래 키 하나로 양방향 연관관계가 관리되지만 객체 연관관계 패러다임에선 그렇지 못하기 때문에, 외래 키 주인이 아닌 쪽에서 읽기만 가능하도록 @OneToMany(mappedBy = ? ) 설정을 함으로써 패러다임의 불일치를 해결한다고 위에서 설명하였었다.<br>
   - 일대 다 단방향 관계를 매핑할 때에는 @JoinColumn( name = FK 필드 이름)을 명시해주어야 한다. (명시하지 않을 시 JPA는 조인 테이블 사용하여 연결 테이블을 중간에 두고 연관관계를 관리한다. TODO)<br>
   - 일대 다 단방향에서 외래키는 자신이 아니라 다른 테이블에 존재하기 때문에 연관관계 처리를 위한 UPDATE query가 추가적으로 수행되어야 하는 단점이 있음. 앵간하면 다대일 양방향 매핑을 사용하자.<br>

  ```java
    main(){
      //일대다 단방향일 경우
      Member member1 = new Member("member1");
      Member member2 = new Member("member2");

      Team team1 = new Team("team1");
      team1.getMembers().add(member1);
      team1.getMembers().add(member2);

      em.persist(member1); //INSERT member1
      em.persist(member2); //INSERT member2

      em.persist(team1);  // INSERT team1 + 
                          //  UPDATE member1.team_id +
                          // UPDATE member2.team_id

      //다대일 양방향일 경우
      Team team1 = new Team("team1");

      Member member1 = new Member("member1");
        member1.setTeam(team1)  //setTeam에는 양방향 매핑을 위한 로직이 있을 것이다.
      Member member2 = new Member("member2");
        member2.setTeam(team1)

        //이 경우 member의 insert query 과정에서 한번에 해결된다.
    }
  ```


## 6.3 일대 일

 - 다 쪽이 외래 키를 관리하는 것과 달리 일대 일 관계에서는 어느 쪽에서든 외래 키를 가지고 관리할 수 있다.<br>
 - 주 테이블에 외래 키를 두는 방법, 대상 테이블에 외래 키를 두는 방법 두 가지 중 하나를 선택할 수 있다.


### 6.3.1 주 테이블에 외래 키

```java
  @Entity
  public class Member{
    @Id
    @Column (name = "member_id")
    private Long id;

    @OneToOne
    @JoinColumn( name = "locker_id" )
    private Locker locker;
  }

  @Entity
  public class Locker{
    @Id
    @Column ( name = "locker_id" )
    private Long id;
//==============여기까지가 단방향===================
  //Member 테이블이 외래 키 주인이므로 아래 코드를 통해
  //연관관계를 매핑하여 양방향 관계로 만들고, 연관관계 주인이 아님을 설정한다.
    @OneToOne( mappedBy = "locker" )
    private Member member
  }
```


### 6.3.2 대상 테이블에 외래 키

 - 단방향 관계는 지원하지 않음.
 - 양방향

```java
  @Entity
  public class Member{
    @Id
    @Column (name = "member_id")
    private Long id;

    @OneToOne ( mappedBy = "member" )
    private  Locker locker;
  }

  @Entity
  public class Locker{
    @Id
    @Column( name = "locker_id" )
    private Long id;

    @OneToOne
    @JoinColumn ( name = "member_id" )
    private Member member;
  }
```

## 6.4 다대 다

 - 단방향


   - RDB에서 다대 다 관계는 정규화 과정을 통해(연결 테이블) 일대 다 - 다대 일 관계로 풀어낸다. 반면 객체의 경우 다대 다 관계를 만들 수 있는데, 양 쪽에 컬렉션으로 상대 객체를 담으면 되기 때문이다. <br> 이러한 불일치를 @ManyToMany를 통해 해결할 수 있다.

 ```java
  @Entity
  public class Member{
    @Id @Column( name = "member_id" )
    private Long id;

    // 1)
    @ManyToMany
    @JoinTable( name = "member_product"
        , joinColumns = @JoinColumn(name = "member_id")
        , inverseJoinColumns = @JoinColumn( name = "product_id" ) )
    private List<Product> products = new ArrayList<>(); 

    // 2)
    @OneToMany( mappedBy = "member" )
    private List<MemberProduct> memberProduct;
  }

  @Entity
  public class Product{
    @Id @Column( name = "product_id" )
    private Long id;

    // 1) 양방향일 경우 추가.
    @ManyToMany( mappedBy = "products" )
    private List<Member> members;

    // 2)
    //상품에서 회원상품 엔티티로 객체 그래프 탐색을 할 일이 없다면 생략해도 된다.
    @OneToMany( mappedBy = "product" )  
    private List<MemberProduct> memberProduct;

  }

  // 2)
  @Entity
  @IdClass (MemberProductId.class)
  public class MemberProduct{
    @Id
    @ManyToOne
    @JoinColumn( name = "member_id" )
    private Member member;

    @Id
    @ManyToOne
    @JoinColumn( name = "product_id" )
    private Product product;

    private int orderAmoun;
    ...
  
  }

  // 2) MemberProduct 식별자 클래스 MemberProductId
  public class MemberProductId implements Serializable{
    private Long member;
    private Long product;

    @Override
    public boolean equals(Object o){...}

    @Override
    public int hashcode(){...}
  }
 ```
 - 양방향
    - 단방향과 다른 점은 참조할 필드를 만들어주면서 @MappedBy와 함께 연관관계의 주인이 아님을 명시해주는 부분이 추가된다.<br>
    - 관리의 편의성을 위해 member쪽에 연관관계 편의 메서드도 추가해주자.


  - 1) 연결 테이블에서 관리하는 것이 fk 뿐일 경우
    - @JoinTable.name : 연결 테이블을 지정한다.
    - @JoinTable.joinColumns : 회원쪽에서 매핑할 컬럼 정보 지정
    - @JoinTable.inverseJoinColumns : 상품쪽에서 매핑할 컬럼 정보 지정
    - 단방향이므로 참조는 한쪽에서만. (member -> product)


  - 2) 연결 테이블에서 관리하는 것이 fk 외에 더 있을 경우 1)대신  추가해야 하는 부분.
    - 연결 테이블을 우리가 만드는 것이 아니기 때문에 추가적으로 관리되어야 할 데이터가 담기는 컬럼들(주문 수량, 주문 날짜 등)을 엔티티와 매핑할 수 없다. 따라서 연결 엔티티를 직접 만들어 추가적인 컬럼들을 매핑하는 방법을 사용한다.<br>
    - 연관관계 주인은 fk를 가지고있는 MemberProduct이므로 다른 쪽에는 mappedBy를 통해 주인이 아님을 명시한다.<br>
    - MemberProduct 엔티티의 기본 키는 member_id와 product_id로 구성된 복합 키이다. 그리고 JPA에서 복합 키를 사용하려면 별도의 식별자 클래스가 필요하기 때문에 MemberProductId를 생성하고 @IdClass를 통해 식별자 클래스임을 명시하였다.<br>
    - 식별자 클래스는
      - Serializable 구현을 통해 직렬화 가능한 객체로 만들어야 하며,
      - equals, hashcode 메서드를 구현해야 하며
      - default constructor가 필요하며
      - class modifier는 public이어야 한다.
      - @EmbeddedId를 이용할 수도 있다.

> MemberProduct가 자신의 부모 테이블(Member, Product)의 기본 키를 받아 자신의 기본 키 + 외래 키로 사용하는 것을 DB에선 식별 관계라고 한다.

 - 예제

```java
  public void save(){
    //회원 저장
    Member member1 = new Member();
    member1.setId("member1");
    em.persist(member1);

    //상품 저장
    Product product1 = new Product();
    product1.setId("product1");

    //회원상품 저장
    MemberProduct mpSave = new MemberProduct();
    mpSave.setMember(member1);
    mpSave.setProduct(product1);
    mpSave.setOrderAmount(5);

    em.persist(mpSave);  //연관관계의 member와 product의 식별자를 가져와서 자신의 기본 키 값으로 사용한다.

    MemberProductId mpId = new MemberProductId();
    mpId.setMember("member1");
    mpId.setProduct("product1");

    MemberProduct mpFind = em.find(MemberProduct.class, mpId);
  }
```
 - 식별 관계로서 부모 테이블의 기본 키를 받아 복합 키로 자신의 기본 키를 구성하는 방법 말고, 비식별 관계로서 부모 테이블의 기본 키를 외래 키로만 사용하는 방법이 권장된다. (식별자 클래스를 별도로 만들지 않아도 되기에.)


```java
  @Entity
  public class MemberProduct{
    @Id @GeneratedValue
    @Column( name = "member_product_id" )
    private Long id;

    //외래 키에서 @Id를 빼고 MemberProduct의 별도 대리키를 구성하도록 한다.
    @ManyToOne
    @JoinColumn( name = "member_id" )
    private Member member;

    @ManyToOne
    @JoinColumn( name = "product_id" )
    private Product product;
  }
```


```java
  @Entity
  //조인 전략
  @Inheritance (strategy = InheritanceType.JOINED)  
  // 단일 테이블 전략
  @Inheritance (strategy = InheritanceType.SINGLE_TABLE)  
  // 구현 클래스마다 테이블 전략(비추천)
  @Inheritance (strategy = InheritanceType.TABLE_PER_CLASS) 

  @DiscriminatorColumn ( name = "DType" )
  public abstract class Animal{
    @Id @GeneratedValue
    @Column ( name = "animal_id" )
    private Long id;

    private String name;
    private String species;
  }

  @Entity
  @DiscriminatorValue ( "F" )
  public class Flying extends Animal{
    private boolean hasFeathers;
    ...
  }

  @Entity
  @DiscriminatorValue ( "M" )
  public class Marine extends Animal{
    private boolean isMammalia;
    ...
  }
```

```java
  @MappedSuperclass
  public abstract class BaseEntiy{
    @Id @GeneratedValue
    private Long id;
    private String name;

  }

  @Entity
  //매핑정보 재정의 방법
  @AttributeOverrides ({
    @AttributeOverride( name = "id", column = @Column( name = "subId1" ) ),
    @AttributeOverride( name = "name", column = @Column ( name = "subName1" ))
  })  
  //연관관계 재정의
  @AssociationOverride(name = "매핑된 필드명", joincolumns = @JoinColumn(name = "재지정할 컬럼명"))
  public class SubEntity1 extends BaseEntity {
    //id와 name은 상속받음
    private String data1;


  }

  @Entity
  public class SubEntity2 extends BaseEntity{
    //id와 name은 상속받음
    private String data2;
  }
```

# **7 장.**　고급 매핑


 - 이 장의 목표
1. 상속 관계 매핑 : 객체의 상속 관계를 데이터베이스에 어떻게 매핑할 것인가?

2. @MappedSuperclass

3. 복합 키 / 식별 관계 매핑

4. 조인 테이블

5. 엔티티 하나에 여러 테이블 매핑




## 7.1 상속 관계 매핑

 - 데이터베이스에는 (1)객체지향에서의 상속이라는 개념은 없지만,
   (2)슈퍼타입-서브타입 관계라는 모델링 기법이 있는데,  ORM에서의 상속 관계 매핑은 (1) + (2)를 매핑하는 것을 의미함.

 - 슈퍼타입-서브타입 모델링 후 물리 테이블 구현 전략 3가지
	(1) 모두 테이블로 만들고 조인(조인 전략)
	(2) 테이블 하나에 통합하여 사용하는 방법(단일 테이블 전략)
	(3) 서브타입마다 하나의 테이블을 만드는 방법(구현 클래스마다 테이블 전략)

	- 매핑 정보
		- @Inheritance(strategy = InheritanceType.전략)
			- 전략 : JOINED, SINGLE_TABLE, TABLE_PER_CLASS
		- @DiscriminatorColumn( name = "DTYPE" )
			- 타입을 구분할 컬럼의 이름. DTYPE = F이면 flyings ...
			- DTYPE이 기본값이기 때문에 생략 가능.
		- @DiscriminatorValue(value)
			- value : 저장될 때 구분 컬럼에 입력할 값. 


### 7.1.1 조인 전략

- 자식 테이블이 부모 테이블의 기본 키를 받아 조인시 사용한다.
- 테이블의 경우 객체와 달리 타입(테이블의 자료형) 개념이 없기 때문에 타입을 구분할 수 있는 컬럼 하나를 추가해준다.


- 자식 테이블은 부모 테이블의 ID 칼럼명을 그대로 사용하나, @PrimaryKeyJoinColumn( name = "사용할_ID_컬럼명" ) 를 통해 바꿀 수 있음.
- 장점
	- 테이블이 정규화됨.
	- 외래 키 참조 무결성 제약조건 활용 가능
	- 저장공간 효율적으로 사용 가능
- 단점
	- 조인 多 -> 성능 저하
	- 조회 쿼리가 복잡
	- INSERT SQL이 두 번 실행됨.(자식 + 부모)

- 특징
	- JPA 표준에서는 구분 컬럼 사용하도록 하지만 hibernate를 비롯한 몇 구현체들은 구분 컬럼 없이도 동작함.



### 7.1.2 단일 테이블 전략

- 특징
 - 한 테이블에 모두 담기 때문에 구분 컬럼 필수로 사용해야 함.
 - DiscriminatorValue 생략시 엔티티 이름 사용.
 - 자식 엔티티가 매핑한 컬럼 모두 nullable 이어야 함.

- 장단점
 - 조인 필요없기 때문에 조회 성능 빠를 수 있으나, 테이블이 커짐에 따라 성능이 오히려 느려질 수도 있음.


### 7.1.3 구현 클래스마다 테이블 전략(추천하지 않는 방법)

- 자식 엔티티마다 테이블 만듬
- 장점
  - 서브 타입을 구분해서 처리할 때 효과적
  - not null 제약조건 사용 가능
- 단점
  - 여러 자식 테이블을 함께 조회할 떄 성능이 느림.(SQL의 UNION 사용해야)
  - 자식 테이블을 통합해서 쿼리하기 힘듬
- 특징
  - 구분 컬럼 사용하지 않음.



## 7.2 @MappedSuperclass

- 부모 클래스와 자식 클래스 모두 테이블과 매핑하는 것이 아니라 자식 클래스에게 매핑 정보만 제공하고자 할 때 사용.
- 즉, @MappedSuperclass가 붙은 클래스는 테이블과 매핑하지 않고 sub class에게 단지 매핑 정보 상속 목적의 클래스라는 것을 명시하는 것.
- @AttributeOverride(s) : 부모로부터 물려받은 매핑정보를 재정의
- @AssociationOverride(s) : 부모로부터 물려받은 연관관계 재정의

- 특징
  - 엔티티가 아니기 때문에 엔티티 기능 사용 불가. JPQL에서 사용 불가.
  - 생성해서 사용할 목적으로 만든 것이 아니기 때문에 거의 추상 클래스로 선언한다



## 7.3 복합 키와 식별 관계 매핑

### 7.3.1 식별 관계 vs 비식별 관계

  - 다른 테이블과의 관계에서 외래 키가 자신의 기본 키에 포함되는지 여부에 따라 식별 관계 / 비식별 관계로 나뉜다.


  - 식별 관계
    - 부모 테이블의 기본 키 또는 유니크 키를 자식 테이블이 자신의 기본 키로 사용하는 관계.
      - Parent의 PK는 Child의 PK & FK


  - 비식별 관계
    - 부모 테이블의 기본 키 또는 유니크 키를 자신의 기본 키로 사용하지 않고, 외래 키로만 사용하는 관계.
    - FK가 nullable인지 여부에 따라
      - NULL 허용 X => 필수적 비식별 관계. 연관관계 필수적으로 맺어야 함.
      - NULL 허용 O => 선택적 비식별 관계. 연관관계 맺을지 말지 선택 가능.


### 7.3.2 복합키 : 비식별 관계 매핑

 - JPA에서 복합키를 사용하기 위해선 별도의 식별자 클래스가 필요함.
   - persist context에서 엔티티를 관리할 때 엔티티의 식별자로 equals, hashcode를 사용해서 비교하기 때문에 두 개 이상의 식별자는 별도 구현이 필요한 것.
   - JPA는 이러한 문제에 대해 @IdClass와 @EmbeddedId를 제공함.

 
  - @IdClass

```java
  @Entity
  @IdClass(ParentId.class)
  public class Parent{
    @Id //복합 키에는 @GeneratedValue 사용 불가.
    @Column ( name = "PARENT_ID1" )
    private String id;

    @Id
    @Column ( name = "PARENT_ID2" )
    private String id2;
  }

  public class ParentId implements Serializable{
    private String id1;
    private String id2;

    public parentId() { }

    public parentId(String id1, String id2) {
      this.id1 = id1;
      this.id2 = id2;
    }
    
    @Override
    public boolean equals(Object o) { ... }

    @Override
    public int hashcode() { ... } 
  }

  @Entity
  public class Child{
    @Id
    private String id;

    @ManyToOne
    @JoinCOlumns({
      //name과 referencedColumnName 같으면 생략 가능.
      @JoinColumn( name = "PARENT_ID1",
    referencedColumnName = "PARENT_ID1" ),
      @JoinColumn( name = "PARENT_ID2", 
    referencedColumnName = "PARENT_ID2" )
    })
    private Parent parent;

  }

  main(){
    Parent parent = new Parent();
    parent.setId1("1");
    parent.setId2("2");
    em.persist(parent);

    ParentId parentId = new ParentId("1", "2");
    Parent parent = em.find(Parent.class, parentId) //식별자 클래스를 통해 조회
  }
```

   - 사용 조건
     - Parent(엔티티)의 식별자 필드명 - ParentId(식별자 클래스)의 필드명 둘이 같아야함.
     - Serializable 구현(직렬화)
     - equals, hashcode 별도 구현
     - 기본 생성자 존재
     - 식별자 클래스의 modifier는 public

   - 동작 방식
     - persist 호출 > 내부에서 **ParentId(식별자 클래스) 생성** > Persistence Context 등록


 - @EmbeddedId

```java
  @Entity
  public class Parent{
    @EmbeddedId
    private ParentId id;
  }

  @Embeddable
  public class ParentId implements Serializable{
      @Column( name = "parent_id1" )
      private String id1;

      @Column ( name = "parent_id2" )
      private String id2;

      @Override
      public boolean equals(Object o){ ... }

      @Overried
      public int hashcode(){ ... } 
  }

  main(){
    Parent parent = new Parent();
    parent.setId(new ParentId("1", "2"));
    em.persist(parent);

    //조회는 동일. @IdClass방식도 ParentId 직접 이용.
  }
```

  - 사용 조건
    - 복합키 컬럼에는 @EmbeddedID, 식별자 클래스에는 @Embeddable
    - Serializable 구현
    - equals, hashcode 별도 구현
    - 기본 생성자 존재
    - 식별자 클래스 modifier는 public

  - 동작
    - @IdClass의 경우 엔티티에 식별자 set 해줬다면 @EmbeddedId는 식별자 클래스 이용.



### 7.3.3 복합키 : 식별 관계 매핑

TODO....