---
title : JPA
categories : [jpa]
tags: [jpa, hibernate]
published: false
---

>본 포스트는 자바 ORM 표준 JPA 프로그래밍(김영한)의 일부 내용을 요약한 글임.
>>[자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/Product/Goods/19040233)

# **1 장.** JPA 소개

  - 따라서 사용하는 객체가 javax.persistence로 시작한다면 JPA 표준 속성이기 때문에 ORM 프레임워크에 종속적이지 않지만, hibernate로 시작한다면 hibernate 구현체이기 때문에 hibernate에서만 사용할 수 있다. 

# **2 장.** JPA 시작

## 2.3 라이브러리와 프로젝트 구조

- hibernate의 핵심 라이브러리
  - hibernate-core
  - hibernate-entitymanager : 하이버네이트가 JPA 구현체로서 동작하도록 구현한 라이브러리.
  - hibernate-jpa-2.1-api : JPA 2.1 표준 API를 모아둔 라이브러리


## 2.5 persistence 설정

  - persistence-unit : 연결할 DB당 하나의 영속성 유닛을 등록하며, 고유한 이름을 부여해야 한다.
  - 그 외에 필수 속성으로 jdbc driver, jdbc user, jdbc password, jdbc url, hibernate.dialect 설정이 필요하다.
  - Optional properties
    - hibernate.show_sql : 하이버네이트가 실행한 SQL 출력
    - hibernate.format_sql : 하이버네이트가 실행한 SQL을 출력할 때 보기 쉽게 정렬.
    - hibernate.use_sql_comments : 주석도 함께 출력.
    - hibernate.id.new_generator_mappings : JPA 표준에 맞춘 새로운 키 생성 전략 사용. TODO



### 　2.6.4 JPQL

  - SQL을 추상화 한 객체지향 쿼리 언어.
  - SQL과 문법이 거의 유사
  - 다만 차이점은 엔티티 객체를 대상으로 쿼리. SQL은 DB Table 대상.
    - JPQL은 테이블 전혀 알지 못함.
  - em.createQuery(JPQL, 반환 타입).getResultList();

<br>
<hr>
<br>



# **4 장.**　엔티티 매핑


## 4.4 데이터베이스 스키마 자동 생성

- JPA는 매핑 정보와 DB Dialect를 활용해 데이터베이스 스키마 생성함.
  - hibernate.hbm2ddl.auto 속성 설정 필요. 다음은 속성 값
    - create : DROP + CREATE
    - create-drop : DROP + CREATE + DROP (create 속성에 애플리케이션 종료시 생성한 DDL 제거.)
    - update : 데이터베이스 테이블과 엔티티 매핑 정보 비교하여 변경 사항만 수정.
    - validate : 데이터베이스 테이블과 엔티티 매핑 정보 비교하여 변경 사항 있으면 경고와 함께 애플리케이션 실행 X. DDL 건드리지 않음.
    - none : 자동 생성 기능 사용X.(이 값은 유효하지 않은 값으로, 속성 자체를 설정 파일에서 지우거나 유효하지 않은 값을 넣으면 기능 사용 X.)
- 다만, 운영 환경에서 사용할 정도로 완성도가 높지 않을 수 있음.
 hibernate.ejb.naming_strategy = org.hibernate.cfg.ImprovedNamingStrategy
  - 자바는 카멜 케이스, 데이터베이스는 언더스코어 표기법 사용하기 때문에 그 차이를 해결해주는 설정.
  - 설정에 위 속성을 추가하면 테이블 혹은 컬럼 명 생략시 언더스코어 표기법으로 DDL 구성.




# **5 장.**　연관관계 매핑 기초

 - 이 장의 목표는 **객체의 참조**와 **테이블의 외래 키**를 매핑하는 것.
 - 관련 키워드
   - 방향(Direction) : 단방향, 양방향이 있으며 한 쪽만이 다른 한쪽을 참조하는 것을 단방향, 서로 참조하는 것을 양방향이라고 함. 테이블의 관계는 항상 양방향임.
   - 다중성(Multiplicity) : 다대일, 일대다, 일대일, 다대다
   - 연관관계의 주인 : 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 함.



## 5.1 단방향 연관관계

 - 테이블의 외래 키를 이용한 연관관계와, 객체 내 참조값을 이용한 연관관계
   - A, B 두 객체가 서로 연관관계가 있을 때 객체 A는 B의 참조값을, B는 A의 참조 값을 갖게 함으로써 양방향 연관관계를 맺게 할 수 있는데, 정확하게 이는 양방향 연관관계가 아니라 서로 다른 단방향 연관관계 2개라고 할 수 있다.
   - 반면 테이블에서 외래 키를 이용한 연관관계는 양방향으로서 A JOIN B 혹은 B JOIN A가 가능하다.



### 5.1.1 순수한 객체 연관관계

 - 객체는 참조값을 사용해 연관관계를 탐색(객체 그래프 탐색)할 수 있다.


### 5.1.2 테이블 연관관계

 - DB에선 테이블의 외래 키를 이용해 연관관계를 탐색(조인)할 수 있다.


### 5.1.3 객체 관계 매핑

![](../../assets/img/relationship_mapping.png)

 - JPA를 통해 객체 연관관계 방식과 테이블 연관관계 방식의 불일치를 해결할 수 있다.

```java
  @Entity
  public class Member{
    @Id
    @Column(name = "MEMBER_ID")
    private String memberId;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;

    ...
  }

  @Entity
  public class Team{
    @Id
    @Column(name = "TEAM_ID")
    private String teamId;

    ...
  }
```

### 5.1.4 @JoinColumn

 - @JoinColumn : 외래 키를 매핑할 때 사용. 생략 가능.
   - 생략하게 되면 외래 키를 찾을 때 기본 전략 사용.
     - 기본 전략 : 필드명+_+참조하는 테이블의 컬럼명
       - team_team_id

속성  | 기능  | 기본값
--- | --- | ---
name  | 외래 키 이름  | 필드명 + "_" 참조하는 테이블의 <br>기본 키 컬럼 명
referencedColumnName  | 외래 키가 참조하는 <br>대상 테이블에서의 컬럼명 | 참조하는 테이블의 <br>기본 키 컬럼명  
foreignKey(DDL) | 외래 키 제약조건을 직접 지정할 수 있음. | 
unique<br>nullable<br>insertable<br>updatable<br>columnDefinition<br>table | @Column의 속성과 같음 | 


 - name과 referencedColumnName의 차이를 설명한 글 : [name vs referencedColumnName](https://stackoverflow.com/questions/53287631/difference-between-name-and-referencedcolumnname-in-joincolumn-annotation)



### 5.1.5 @ManyToOne

 - @ManyToOne : 다대일 관계를 알려주는 매핑 정보

속성  | 기능  | 기본값
--- | --- | ---
optional  | false시 연관된 엔티티가 항상 있어야 한다. <br> true시에는 엔티티가 없는 경우도 조회한다(Outer Join) | true
cascade | 엔티티의 상태 변화를 전파시키는 옵션 | 
targetEntity | 연관된 엔티티의 타입 정보를 설정 | 

 - targetEntity
   - 제네릭으로 타입 정보를 알 수 있기 때문에 사용하지 않아도 됨.
     - ex)

     ```java
      @OneToMany
      private List<Memeber> members

      @OneToMany(targetEntity = Member.class)
      private List Members;
     ```
<br>

## 5.2 연관관계 사용


### 5.2.2 조회

 - 연관관계가 있는 엔티티를 조회하는 방법은 크게 2가지
   - 객체 그래프 탐색(객체 연관관계를 사용한 조회)
     - ex)
     
     ```java
      Member.member = em.find(Member.class, "member1");
      Team team = member.getTeaml();  //객체 그래프 탐색
     ```

   - 객체지향 쿼리(JPQL) 사용.
     - ex)
     
     ```java
      String jpql = "select m from member m join m.team t "
        + "where t.name=:teamname";

      List<Member> resultList = em.createQuery(jpql, Member.class)
      .setParameter("teamName", "팀1")
      .getResultList();
     ```


### 5.2.4 연관관계 제거

```java
  Member member = em.find(Member.class, "member1");
  member.setTeam(null);
```

### 5.2.5 연관된 엔티티 삭제

```java
member.setTeam(null);
em.remove(team);
```
 - 연관관계 제거가 우선적으로 수행되고 나서 연관된 엔티티를 삭제하도록 한다.


## 5.3 양방향 연관관계

 - 테이블 연관관계의 경우 외래 키 하나로 애초에 양방향 연관관계가 관리되지만, 객체 연관관계의 경우 단방향 연관관계만이 존재하기 때문에 단방향 연관관계 두 개로 테이블에서의 양방향 연관관계처럼 구현한다. (이 과정에서 테이블의 양방향 연관관계에서 외래 키 하나를 사용하는 것 처럼 객체 양방향 연관관계에서도 외래 키 필드 하나로 관리되도록 mappedBy 속성을 사용한다. 그렇지 않으면 A의 필드 b(외래키)와 B의 필드 a(외래키) 연관관계를 관리하는 것이 두 개가 되고 이는 테이블 연관관계의 패러다임과 맞지 않다.)
<br>따라서 기존에 존재하던 Member -> Team 연관관계 외에 Team -> Member 연관관계를 설정해주어야 한다.

```java
  @Entity
  public class Team{
    ...
    //여기서 mappedBy = team의 team은 반대쪽 매핑 필드명.
    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<Member>();
  }

  //이제 member.getTeam() 말고 team.getMembers()도 가능하다.
  List<Member> members = team.getMembers();

```


## 5.4 연관관계의 주인
<br>
 - 위에서 기술한 것처럼 객체 양방향 연관관계를 관리하는 외래 키 필드를 테이블 양방향 연관관계처럼 만들기 위해 mappedBy를 사용하는데,<br> 두 객체 연관관계 중 하나를 정해 테이블의 외래 키를 관리하게 하는 것을 연관관계의 주인이라고 한다.<br>
 - 연관관계 주인 쪽에서만 외래 키를 관리(등록, 수정, 삭제)할 수 있고 다른 한 쪽은 읽기만 가능.<br>
 - mappedBy는 주인이 아닌 쪽에서 사용한다.<br>


### 5.4.2 연관관계의 주인은 외래 키가 있는 곳
<br>
 - 연관관계 주인은 테이블에 외래 키가 있는 곳으로 정해야 하기 때문에 Member.team이 주인이 되며, Team.members는 mappedBy=team 속성을 통해 주인이 아님을 명시한다.<br>
 - 다대 일, 일대 다 관계를 살펴보면 항상 다 쪽에서 외래 키를 가지고 있다. 따라서 다 쪽인 ManyToOne은 항상 연관관계의 주인이므로 mappedBy 설정 불가. 이에 따라 속성에 mappedBy가 아예 없음.<br>


## 5.6 양방향 연관관계의 주의점

```java
//1)
  team.getMembers().add(member1); //(X)
//2)
  member1.setTeam(team1); // (O)
```
<br>
 - 연관관계의 주인이 아닌 곳에만 값을 입력해선 안된다.<br> 주인이 아닌 쪽에서 외래 키는 readOnly이므로 member쪽에서 별도로 입력하는게 아닌 이상 값이 입력되지 않는다.<br>
 - 또한 연관관계 주인에만 값을 입력해서도 안된다. 테이블 연관관계의 패러다임 상에서는 주인 쪽에만 값을 입력하면 외래 키를 통해 양방향 연관관계가 관리되지만, 객체 연관관계 패러다임 상에서는 한 쪽에 값을 넣는다고 해서 다른 쪽에서도 이를 이용해 관리되지는 않기 때문이다.<br>

예를 들어

```java

  public class A{
    @ManyToOne
    @JoinColumn(~~)
    private B b;
  }

  public class B{
    @OneToMany(mappedBy="b"
    //, targetEntity = A.class
    )
    private List<A> list = new ArrayList<>();
  }

  main(){
    B b1 = new B();
    A a1 = new A();

    a1.setB(b1);
    
    //1)
    a1.getB();

    //2)
    b.getList()
  }

```

 - 1의 실행 결과는 b1의 값이 나올테지만, 2의 실행 결과는 당연히 빈 arraylist가 나올 것이다. <br>

 - 따라서 결론은 객체 연관관계 패러다임까지 고려하여 양 쪽에 값을 다 넣어주는 것이 양방향 연관관계를 사용하는 과정에서 안전할 것이다.<br>

```java

  public class A{
    private B b;

    public void setB(B b){
      if(this.b != null){
        //연관관계가 바뀔때를 대비한 로직.
        //이 로직이 없으면 B쪽의 a에 대한 연관관계가 list에 남아있게 된다.
        this.b.getList().remove(this);  

        this.b = b;
        this.b.getList().add(this);        
      }
    }
  }
```


# **6 장.**　다양한 연관관계 매핑

 - 다대 일 양방향 관계와 비교되는 일대 다 단방향 관계의 단점
   - 테이블 연관관계 패러다임에선 외래 키 하나로 양방향 연관관계가 관리되지만 객체 연관관계 패러다임에선 그렇지 못하기 때문에, 외래 키 주인이 아닌 쪽에서 읽기만 가능하도록 @OneToMany(mappedBy = ? ) 설정을 함으로써 패러다임의 불일치를 해결한다고 위에서 설명하였었다.<br>
   - 일대 다 단방향 관계를 매핑할 때에는 @JoinColumn( name = FK 필드 이름)을 명시해주어야 한다. (명시하지 않을 시 JPA는 조인 테이블 사용하여 연결 테이블을 중간에 두고 연관관계를 관리한다. TODO)<br>
   - 일대 다 단방향에서 외래키는 자신이 아니라 다른 테이블에 존재하기 때문에 연관관계 처리를 위한 UPDATE query가 추가적으로 수행되어야 하는 단점이 있음. 앵간하면 다대일 양방향 매핑을 사용하자.<br>

  ```java
    main(){
      //일대다 단방향일 경우
      Member member1 = new Member("member1");
      Member member2 = new Member("member2");

      Team team1 = new Team("team1");
      team1.getMembers().add(member1);
      team1.getMembers().add(member2);

      em.persist(member1); //INSERT member1
      em.persist(member2); //INSERT member2

      em.persist(team1);  // INSERT team1 + 
                          //  UPDATE member1.team_id +
                          // UPDATE member2.team_id

      //다대일 양방향일 경우
      Team team1 = new Team("team1");

      Member member1 = new Member("member1");
        member1.setTeam(team1)  //setTeam에는 양방향 매핑을 위한 로직이 있을 것이다.
      Member member2 = new Member("member2");
        member2.setTeam(team1)

        //이 경우 member의 insert query 과정에서 한번에 해결된다.
    }
  ```


## 6.3 일대 일

 - 다 쪽이 외래 키를 관리하는 것과 달리 일대 일 관계에서는 어느 쪽에서든 외래 키를 가지고 관리할 수 있다.<br>
 - 주 테이블에 외래 키를 두는 방법, 대상 테이블에 외래 키를 두는 방법 두 가지 중 하나를 선택할 수 있다.


### 6.3.1 주 테이블에 외래 키

```java
  @Entity
  public class Member{
    @Id
    @Column (name = "member_id")
    private Long id;

    @OneToOne
    @JoinColumn( name = "locker_id" )
    private Locker locker;
  }

  @Entity
  public class Locker{
    @Id
    @Column ( name = "locker_id" )
    private Long id;
//==============여기까지가 단방향===================
  //Member 테이블이 외래 키 주인이므로 아래 코드를 통해
  //연관관계를 매핑하여 양방향 관계로 만들고, 연관관계 주인이 아님을 설정한다.
    @OneToOne( mappedBy = "locker" )
    private Member member
  }
```


### 6.3.2 대상 테이블에 외래 키

 - 단방향 관계는 지원하지 않음.
 - 양방향

```java
  @Entity
  public class Member{
    @Id
    @Column (name = "member_id")
    private Long id;

    @OneToOne ( mappedBy = "member" )
    private  Locker locker;
  }

  @Entity
  public class Locker{
    @Id
    @Column( name = "locker_id" )
    private Long id;

    @OneToOne
    @JoinColumn ( name = "member_id" )
    private Member member;
  }
```

## 6.4 다대 다

 - 단방향


   - RDB에서 다대 다 관계는 정규화 과정을 통해(연결 테이블) 일대 다 - 다대 일 관계로 풀어낸다. 반면 객체의 경우 다대 다 관계를 만들 수 있는데, 양 쪽에 컬렉션으로 상대 객체를 담으면 되기 때문이다. <br> 이러한 불일치를 @ManyToMany를 통해 해결할 수 있다.

 ```java
  @Entity
  public class Member{
    @Id @Column( name = "member_id" )
    private Long id;

    // 1)
    @ManyToMany
    @JoinTable( name = "member_product"
        , joinColumns = @JoinColumn(name = "member_id")
        , inverseJoinColumns = @JoinColumn( name = "product_id" ) )
    private List<Product> products = new ArrayList<>(); 

    // 2)
    @OneToMany( mappedBy = "member" )
    private List<MemberProduct> memberProduct;
  }

  @Entity
  public class Product{
    @Id @Column( name = "product_id" )
    private Long id;

    // 1) 양방향일 경우 추가.
    @ManyToMany( mappedBy = "products" )
    private List<Member> members;

    // 2)
    //상품에서 회원상품 엔티티로 객체 그래프 탐색을 할 일이 없다면 생략해도 된다.
    @OneToMany( mappedBy = "product" )  
    private List<MemberProduct> memberProduct;

  }

  // 2)
  @Entity
  @IdClass (MemberProductId.class)
  public class MemberProduct{
    @Id
    @ManyToOne
    @JoinColumn( name = "member_id" )
    private Member member;

    @Id
    @ManyToOne
    @JoinColumn( name = "product_id" )
    private Product product;

    private int orderAmoun;
    ...
  
  }

  // 2) MemberProduct 식별자 클래스 MemberProductId
  public class MemberProductId implements Serializable{
    private Long member;
    private Long product;

    @Override
    public boolean equals(Object o){...}

    @Override
    public int hashcode(){...}
  }
 ```
 - 양방향
    - 단방향과 다른 점은 참조할 필드를 만들어주면서 @MappedBy와 함께 연관관계의 주인이 아님을 명시해주는 부분이 추가된다.<br>
    - 관리의 편의성을 위해 member쪽에 연관관계 편의 메서드도 추가해주자.


  - 1) 연결 테이블에서 관리하는 것이 fk 뿐일 경우
    - @JoinTable.name : 연결 테이블을 지정한다.
    - @JoinTable.joinColumns : 회원쪽에서 매핑할 컬럼 정보 지정
    - @JoinTable.inverseJoinColumns : 상품쪽에서 매핑할 컬럼 정보 지정
    - 단방향이므로 참조는 한쪽에서만. (member -> product)


  - 2) 연결 테이블에서 관리하는 것이 fk 외에 더 있을 경우 1)대신  추가해야 하는 부분.
    - 연결 테이블을 우리가 만드는 것이 아니기 때문에 추가적으로 관리되어야 할 데이터가 담기는 컬럼들(주문 수량, 주문 날짜 등)을 엔티티와 매핑할 수 없다. 따라서 연결 엔티티를 직접 만들어 추가적인 컬럼들을 매핑하는 방법을 사용한다.<br>
    - 연관관계 주인은 fk를 가지고있는 MemberProduct이므로 다른 쪽에는 mappedBy를 통해 주인이 아님을 명시한다.<br>
    - MemberProduct 엔티티의 기본 키는 member_id와 product_id로 구성된 복합 키이다. 그리고 JPA에서 복합 키를 사용하려면 별도의 식별자 클래스가 필요하기 때문에 MemberProductId를 생성하고 @IdClass를 통해 식별자 클래스임을 명시하였다.<br>
    - 식별자 클래스는
      - Serializable 구현을 통해 직렬화 가능한 객체로 만들어야 하며,
      - equals, hashcode 메서드를 구현해야 하며
      - default constructor가 필요하며
      - class modifier는 public이어야 한다.
      - @EmbeddedId를 이용할 수도 있다.

> MemberProduct가 자신의 부모 테이블(Member, Product)의 기본 키를 받아 자신의 기본 키 + 외래 키로 사용하는 것을 DB에선 식별 관계라고 한다.

 - 예제

```java
  public void save(){
    //회원 저장
    Member member1 = new Member();
    member1.setId("member1");
    em.persist(member1);

    //상품 저장
    Product product1 = new Product();
    product1.setId("product1");

    //회원상품 저장
    MemberProduct mpSave = new MemberProduct();
    mpSave.setMember(member1);
    mpSave.setProduct(product1);
    mpSave.setOrderAmount(5);

    em.persist(mpSave);  //연관관계의 member와 product의 식별자를 가져와서 자신의 기본 키 값으로 사용한다.

    MemberProductId mpId = new MemberProductId();
    mpId.setMember("member1");
    mpId.setProduct("product1");

    MemberProduct mpFind = em.find(MemberProduct.class, mpId);
  }
```
 - 식별 관계로서 부모 테이블의 기본 키를 받아 복합 키로 자신의 기본 키를 구성하는 방법 말고, 비식별 관계로서 부모 테이블의 기본 키를 외래 키로만 사용하는 방법이 권장된다. (식별자 클래스를 별도로 만들지 않아도 되기에.)


```java
  @Entity
  public class MemberProduct{
    @Id @GeneratedValue
    @Column( name = "member_product_id" )
    private Long id;

    //외래 키에서 @Id를 빼고 MemberProduct의 별도 대리키를 구성하도록 한다.
    @ManyToOne
    @JoinColumn( name = "member_id" )
    private Member member;

    @ManyToOne
    @JoinColumn( name = "product_id" )
    private Product product;
  }
```


```java
  @Entity
  //조인 전략
  @Inheritance (strategy = InheritanceType.JOINED)  
  // 단일 테이블 전략
  @Inheritance (strategy = InheritanceType.SINGLE_TABLE)  
  // 구현 클래스마다 테이블 전략(비추천)
  @Inheritance (strategy = InheritanceType.TABLE_PER_CLASS) 

  @DiscriminatorColumn ( name = "DType" )
  public abstract class Animal{
    @Id @GeneratedValue
    @Column ( name = "animal_id" )
    private Long id;

    private String name;
    private String species;
  }

  @Entity
  @DiscriminatorValue ( "F" )
  public class Flying extends Animal{
    private boolean hasFeathers;
    ...
  }

  @Entity
  @DiscriminatorValue ( "M" )
  public class Marine extends Animal{
    private boolean isMammalia;
    ...
  }
```

```java
  @MappedSuperclass
  public abstract class BaseEntiy{
    @Id @GeneratedValue
    private Long id;
    private String name;

  }

  @Entity
  //매핑정보 재정의 방법
  @AttributeOverrides ({
    @AttributeOverride( name = "id", column = @Column( name = "subId1" ) ),
    @AttributeOverride( name = "name", column = @Column ( name = "subName1" ))
  })  
  //연관관계 재정의
  @AssociationOverride(name = "매핑된 필드명", joincolumns = @JoinColumn(name = "재지정할 컬럼명"))
  public class SubEntity1 extends BaseEntity {
    //id와 name은 상속받음
    private String data1;


  }

  @Entity
  public class SubEntity2 extends BaseEntity{
    //id와 name은 상속받음
    private String data2;
  }
```

# **7 장.**　고급 매핑


 - 이 장의 목표
1. 상속 관계 매핑 : 객체의 상속 관계를 데이터베이스에 어떻게 매핑할 것인가?

2. @MappedSuperclass

3. 복합 키 / 식별 관계 매핑

4. 조인 테이블

5. 엔티티 하나에 여러 테이블 매핑




## 7.1 상속 관계 매핑

 - 데이터베이스에는 (1)객체지향에서의 상속이라는 개념은 없지만,
   (2)슈퍼타입-서브타입 관계라는 모델링 기법이 있는데,  ORM에서의 상속 관계 매핑은 (1) + (2)를 매핑하는 것을 의미함.

 - 슈퍼타입-서브타입 모델링 후 물리 테이블 구현 전략 3가지
	(1) 모두 테이블로 만들고 조인(조인 전략)
	(2) 테이블 하나에 통합하여 사용하는 방법(단일 테이블 전략)
	(3) 서브타입마다 하나의 테이블을 만드는 방법(구현 클래스마다 테이블 전략)

	- 매핑 정보
		- @Inheritance(strategy = InheritanceType.전략)
			- 전략 : JOINED, SINGLE_TABLE, TABLE_PER_CLASS
		- @DiscriminatorColumn( name = "DTYPE" )
			- 타입을 구분할 컬럼의 이름. DTYPE = F이면 flyings ...
			- DTYPE이 기본값이기 때문에 생략 가능.
		- @DiscriminatorValue(value)
			- value : 저장될 때 구분 컬럼에 입력할 값. 


### 7.1.1 조인 전략

- 자식 테이블이 부모 테이블의 기본 키를 받아 조인시 사용한다.
- 테이블의 경우 객체와 달리 타입(테이블의 자료형) 개념이 없기 때문에 타입을 구분할 수 있는 컬럼 하나를 추가해준다.


- 자식 테이블은 부모 테이블의 ID 칼럼명을 그대로 사용하나, @PrimaryKeyJoinColumn( name = "사용할_ID_컬럼명" ) 를 통해 바꿀 수 있음.
- 장점
	- 테이블이 정규화됨.
	- 외래 키 참조 무결성 제약조건 활용 가능
	- 저장공간 효율적으로 사용 가능
- 단점
	- 조인 多 -> 성능 저하
	- 조회 쿼리가 복잡
	- INSERT SQL이 두 번 실행됨.(자식 + 부모)

- 특징
	- JPA 표준에서는 구분 컬럼 사용하도록 하지만 hibernate를 비롯한 몇 구현체들은 구분 컬럼 없이도 동작함.



### 7.1.2 단일 테이블 전략

- 특징
 - 한 테이블에 모두 담기 때문에 구분 컬럼 필수로 사용해야 함.
 - DiscriminatorValue 생략시 엔티티 이름 사용.
 - 자식 엔티티가 매핑한 컬럼 모두 nullable 이어야 함.

- 장단점
 - 조인 필요없기 때문에 조회 성능 빠를 수 있으나, 테이블이 커짐에 따라 성능이 오히려 느려질 수도 있음.


### 7.1.3 구현 클래스마다 테이블 전략(추천하지 않는 방법)

- 자식 엔티티마다 테이블 만듬
- 장점
  - 서브 타입을 구분해서 처리할 때 효과적
  - not null 제약조건 사용 가능
- 단점
  - 여러 자식 테이블을 함께 조회할 떄 성능이 느림.(SQL의 UNION 사용해야)
  - 자식 테이블을 통합해서 쿼리하기 힘듬
- 특징
  - 구분 컬럼 사용하지 않음.



## 7.2 @MappedSuperclass

- 부모 클래스와 자식 클래스 모두 테이블과 매핑하는 것이 아니라 자식 클래스에게 매핑 정보만 제공하고자 할 때 사용.
- 즉, @MappedSuperclass가 붙은 클래스는 테이블과 매핑하지 않고 sub class에게 단지 매핑 정보 상속 목적의 클래스라는 것을 명시하는 것.
- @AttributeOverride(s) : 부모로부터 물려받은 매핑정보를 재정의
- @AssociationOverride(s) : 부모로부터 물려받은 연관관계 재정의

- 특징
  - 엔티티가 아니기 때문에 엔티티 기능 사용 불가. JPQL에서 사용 불가.
  - 생성해서 사용할 목적으로 만든 것이 아니기 때문에 거의 추상 클래스로 선언한다



## 7.3 복합 키와 식별 관계 매핑

### 7.3.1 식별 관계 vs 비식별 관계

  - 다른 테이블과의 관계에서 외래 키가 자신의 기본 키에 포함되는지 여부에 따라 식별 관계 / 비식별 관계로 나뉜다.


  - 식별 관계
    - 부모 테이블의 기본 키 또는 유니크 키를 자식 테이블이 자신의 기본 키로 사용하는 관계.
      - Parent의 PK는 Child의 PK & FK


  - 비식별 관계
    - 부모 테이블의 기본 키 또는 유니크 키를 자신의 기본 키로 사용하지 않고, 외래 키로만 사용하는 관계.
    - FK가 nullable인지 여부에 따라
      - NULL 허용 X => 필수적 비식별 관계. 연관관계 필수적으로 맺어야 함.
      - NULL 허용 O => 선택적 비식별 관계. 연관관계 맺을지 말지 선택 가능.


### 7.3.2 복합키 : 비식별 관계 매핑

 - JPA에서 복합키를 사용하기 위해선 별도의 식별자 클래스가 필요함.
   - persist context에서 엔티티를 관리할 때 엔티티의 식별자로 equals, hashcode를 사용해서 비교하기 때문에 두 개 이상의 식별자는 별도 구현이 필요한 것.
   - JPA는 이러한 문제에 대해 @IdClass와 @EmbeddedId를 제공함.

 
  - @IdClass

```java
  @Entity
  @IdClass(ParentId.class)
  public class Parent{
    @Id //복합 키에는 @GeneratedValue 사용 불가.
    @Column ( name = "PARENT_ID1" )
    private String id;

    @Id
    @Column ( name = "PARENT_ID2" )
    private String id2;
  }

  public class ParentId implements Serializable{
    private String id1;
    private String id2;

    public parentId() { }

    public parentId(String id1, String id2) {
      this.id1 = id1;
      this.id2 = id2;
    }
    
    @Override
    public boolean equals(Object o) { ... }

    @Override
    public int hashcode() { ... } 
  }

  @Entity
  public class Child{
    @Id
    private String id;

    @ManyToOne
    @JoinCOlumns({
      //name과 referencedColumnName 같으면 생략 가능.
      @JoinColumn( name = "PARENT_ID1",
    referencedColumnName = "PARENT_ID1" ),
      @JoinColumn( name = "PARENT_ID2", 
    referencedColumnName = "PARENT_ID2" )
    })
    private Parent parent;

  }

  main(){
    Parent parent = new Parent();
    parent.setId1("1");
    parent.setId2("2");
    em.persist(parent);

    ParentId parentId = new ParentId("1", "2");
    Parent parent = em.find(Parent.class, parentId) //식별자 클래스를 통해 조회
  }
```

   - 사용 조건
     - Parent(엔티티)의 식별자 필드명 - ParentId(식별자 클래스)의 필드명 둘이 같아야함.
     - Serializable 구현(직렬화)
     - equals, hashcode 별도 구현
     - 기본 생성자 존재
     - 식별자 클래스의 modifier는 public

   - 동작 방식
     - persist 호출 > 내부에서 **ParentId(식별자 클래스) 생성** > Persistence Context 등록


 - @EmbeddedId

```java
  @Entity
  public class Parent{
    @EmbeddedId
    private ParentId id;
  }

  @Embeddable
  public class ParentId implements Serializable{
      @Column( name = "parent_id1" )
      private String id1;

      @Column ( name = "parent_id2" )
      private String id2;

      @Override
      public boolean equals(Object o){ ... }

      @Overried
      public int hashcode(){ ... } 
  }

  main(){
    Parent parent = new Parent();
    parent.setId(new ParentId("1", "2"));
    em.persist(parent);

    //조회는 동일. @IdClass방식도 ParentId 직접 이용.
  }
```

  - 사용 조건
    - 복합키 컬럼에는 @EmbeddedID, 식별자 클래스에는 @Embeddable
    - Serializable 구현
    - equals, hashcode 별도 구현
    - 기본 생성자 존재
    - 식별자 클래스 modifier는 public

  - 동작
    - @IdClass의 경우 엔티티에 식별자 set 해줬다면 @EmbeddedId는 식별자 클래스 이용.



### 7.3.3 복합키 : 식별 관계 매핑

TODO....